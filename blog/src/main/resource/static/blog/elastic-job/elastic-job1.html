<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="490"/>

<div>
<span><div>目标：梳理清楚作业从创建到调度执行的过程</div><div>1、创建JOB的步骤。</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>1、先创建LiteJobConfiguration对象</div><div>private LiteJobConfiguration configuration(String jobName,</div><div>                                           String cron,</div><div>                                           int shardingTotalCount,</div><div>                                           String shardingItemParameters,</div><div>                                           String jobParameters,</div><div>                                           String jobClass) {</div><div>    JobCoreConfiguration coreConfiguration = JobCoreConfiguration.newBuilder(jobName, cron, shardingTotalCount)</div><div>            .shardingItemParameters(shardingItemParameters).jobParameter(jobParameters).build();</div><div>    SimpleJobConfiguration simpleJobConfiguration = new SimpleJobConfiguration(coreConfiguration, jobClass);</div><div>    String jobShardingStrategyClass = AverageAllocationJobShardingStrategy.class.getCanonicalName();</div><div>    LiteJobConfiguration simpleJobRootConfig = LiteJobConfiguration.newBuilder(simpleJobConfiguration).jobShardingStrategyClass(jobShardingStrategyClass).build();</div><div>    return simpleJobRootConfig;</div><div>}</div><div>2、创建JobScheduler对象，然后调用init方法</div><div>@Bean(initMethod = &quot;init&quot;)</div><div>public JobScheduler myJobScheduler(LiteJobConfiguration scannerJob, ZookeeperRegistryCenter registryCenter) {</div><div>    return new JobScheduler(registryCenter, scannerJob);</div><div>}</div></div><div><br/></div><div>2、ZookeeperRegistryCenter类</div><div>    先看一下初始化</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>*</div><div>* @param serverList zookeeper 服务地址列表</div><div>* @param namespace 业务的命名空间,全局唯一</div><div>* @return</div><div>*/</div><div>@Bean(initMethod = &quot;init&quot;)</div><div>public ZookeeperRegistryCenter regCenter(@Value(&quot;${regCenter.serverList}&quot;) final String serverList,</div><div>                                         @Value(&quot;${regCenter.namespace}&quot;) final String namespace) {</div><div>    return new ZookeeperRegistryCenter(new ZookeeperConfiguration(serverList, namespace));</div><div>}</div></div><div>类ZookeeperConfiguration用来存储zookeeper连接的一些基本信息</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 基于Zookeeper的注册中心配置.</div><div>*</div><div>* @author zhangliang</div><div>* @author caohao</div><div>*/</div><div>@Getter</div><div>@Setter</div><div>@RequiredArgsConstructor</div><div>public final class ZookeeperConfiguration {</div><div>    </div><div>    /**</div><div>     * 连接Zookeeper服务器的列表.</div><div>     * 包括IP地址和端口号.</div><div>     * 多个地址用逗号分隔.</div><div>     * 如: host1:2181,host2:2181</div><div>     */</div><div>    private final String serverLists;</div><div>    </div><div>    /**</div><div>     * 命名空间.</div><div>     */</div><div>    private final String namespace;</div><div>    </div><div>    /**</div><div>     * 等待重试的间隔时间的初始值.</div><div>     * 单位毫秒.</div><div>     */</div><div>    private int baseSleepTimeMilliseconds = 1000;</div><div>    </div><div>    /**</div><div>     * 等待重试的间隔时间的最大值.</div><div>     * 单位毫秒.</div><div>     */</div><div>    private int maxSleepTimeMilliseconds = 3000;</div><div>    </div><div>    /**</div><div>     * 最大重试次数.</div><div>     */</div><div>    private int maxRetries = 3;</div><div>    </div><div>    /**</div><div>     * 会话超时时间.</div><div>     * 单位毫秒.</div><div>     */</div><div>    private int sessionTimeoutMilliseconds;</div><div>    </div><div>    /**</div><div>     * 连接超时时间.</div><div>     * 单位毫秒.</div><div>     */</div><div>    private int connectionTimeoutMilliseconds;</div><div>    </div><div>    /**</div><div>     * 连接Zookeeper的权限令牌.</div><div>     * 缺省为不需要权限验证.</div><div>     */</div><div>    private String digest;</div><div>}</div></div><div>ZookeeperRegistryCenter的init方法主要是构建一个zookeeper的连接客户端，执行一些初始化操作。如：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>CuratorFrameworkFactory.Builder builder = CuratorFrameworkFactory.builder()</div><div>        .connectString(zkConfig.getServerLists())</div><div>        .retryPolicy(new ExponentialBackoffRetry(zkConfig.getBaseSleepTimeMilliseconds(), zkConfig.getMaxRetries(), zkConfig.getMaxSleepTimeMilliseconds()))</div><div>        .namespace(zkConfig.getNamespace());</div></div><div>3、JobScheduler涉及的类</div><div>    </div><div>挨个分析上面用到的类</div><div>JobCoreConfiguration用于存储任务的名称、分片数等任务相关的配置信息，里面有多个参数，使用了构造者模式进行解耦构建。</div><div>    SimpleJobConfiguration 是三种任务类型中的一个，将上面JobCoreConfiguration包装了一层。</div><div>    </div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public final class SimpleJobConfiguration implements JobTypeConfiguration {</div><div>    </div><div>    private final JobCoreConfiguration coreConfig;</div><div>    </div><div>    private final JobType jobType = JobType.SIMPLE;</div><div>    </div><div>    private final String jobClass;</div><div>}</div></div><div>再来看一下任务类型</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public enum JobType {</div><div>    </div><div>    SIMPLE, DATAFLOW, SCRIPT</div><div>}</div></div><div><br/></div><div>AverageAllocationJobShardingStrategy这个是分片策略，嗯，写到此处，暂停了一下，顺手写一篇分片策略分析的文章。</div><div><br/></div><div>看一下的上面调用的构造函数</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public JobScheduler(final CoordinatorRegistryCenter regCenter, final LiteJobConfiguration liteJobConfig, final ElasticJobListener... elasticJobListeners) {</div><div>    this(regCenter, liteJobConfig, new JobEventBus(), elasticJobListeners);</div><div>}</div></div><div>其中new了一个JobEventBus（运行痕迹事件总线）对象，看了一眼构造函数，什么也没干，先不管他，等后续有用到的地方再看。</div><div>JobScheduler的构造函数是可以接收0或多个ElasticJobListener，下面看下这个监听器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 弹性化分布式作业监听器接口.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>public interface ElasticJobListener {</div><div>    </div><div>    /**</div><div>     * 作业执行前的执行的方法.</div><div>     *</div><div>     * @param shardingContexts 分片上下文</div><div>     */</div><div>    void beforeJobExecuted(final ShardingContexts shardingContexts);</div><div>    </div><div>    /**</div><div>     * 作业执行后的执行的方法.</div><div>     *</div><div>     * @param shardingContexts 分片上下文</div><div>     */</div><div>    void afterJobExecuted(final ShardingContexts shardingContexts);</div><div>}</div></div><div>这个注释写的，一眼就知道这个监听器的作用了。</div><div><br/></div><div>上面构造器调用了私有构造器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private JobScheduler(final CoordinatorRegistryCenter regCenter, final LiteJobConfiguration liteJobConfig, final JobEventBus jobEventBus, final ElasticJobListener... elasticJobListeners) {</div><div>    JobRegistry.getInstance().addJobInstance(liteJobConfig.getJobName(), new JobInstance());</div><div>    this.liteJobConfig = liteJobConfig;</div><div>    this.regCenter = regCenter;</div><div>    List&lt;ElasticJobListener&gt; elasticJobListenerList = Arrays.asList(elasticJobListeners);</div><div>    setGuaranteeServiceForElasticJobListeners(regCenter, elasticJobListenerList);</div><div>    schedulerFacade = new SchedulerFacade(regCenter, liteJobConfig.getJobName(), elasticJobListenerList);</div><div>    jobFacade = new LiteJobFacade(regCenter, liteJobConfig.getJobName(), Arrays.asList(elasticJobListeners), jobEventBus);</div><div>}</div></div><div><br/></div><div>看一下JobInstance</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 作业运行实例.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>@RequiredArgsConstructor</div><div>@Getter</div><div>@EqualsAndHashCode(of = &quot;jobInstanceId&quot;)</div><div>public final class JobInstance {</div><div>    </div><div>    private static final String DELIMITER = &quot;@-@&quot;;</div><div>    </div><div>    /**</div><div>     * 作业实例主键.</div><div>     */</div><div>    private final String jobInstanceId;</div><div>    </div><div>    public JobInstance() {</div><div>        jobInstanceId = IpUtils.getIp() + DELIMITER + UUID.randomUUID().toString();</div><div>    }</div><div>    </div><div>    /**</div><div>     * 获取作业服务器IP地址.</div><div>     */</div><div>    public String getIp() {</div><div>        return jobInstanceId.substring(0, jobInstanceId.indexOf(DELIMITER));</div><div>    }</div><div>}</div></div><div>作业运行实例，我暂时把它理解为服务器的运行实例，每个运行实例的id以ip+uuid生成唯一标志。</div><div><br/></div><div>看一下JobRegistry</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 作业注册表.</div><div>*</div><div>* @author zhangliang</div><div>* @author caohao</div><div>*/</div><div>@NoArgsConstructor(access = AccessLevel.PRIVATE)</div><div>public final class JobRegistry {</div><div>    </div><div>    private static volatile JobRegistry instance;</div><div>    //存储作业调度控制器</div><div>    private Map&lt;String, JobScheduleController&gt; schedulerMap = new ConcurrentHashMap&lt;&gt;();</div><div>    //存储注册中心</div><div>    private Map&lt;String, CoordinatorRegistryCenter&gt; regCenterMap = new ConcurrentHashMap&lt;&gt;();</div><div>    //存储作业实例</div><div>    private Map&lt;String, JobInstance&gt; jobInstanceMap = new ConcurrentHashMap&lt;&gt;();</div><div>    </div><div>    private Map&lt;String, Boolean&gt; jobRunningMap = new ConcurrentHashMap&lt;&gt;();</div><div>    //存储作业分片数</div><div>    private Map&lt;String, Integer&gt; currentShardingTotalCountMap = new ConcurrentHashMap&lt;&gt;();</div><div>    </div></div><div>JobRegistry注册器，存储作业信息的。这些成员变量上没有写注释，但是从名字上基本可以猜到其大概用途。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static JobRegistry getInstance() {</div><div>    if (null == instance) {</div><div>        synchronized (JobRegistry.class) {</div><div>            if (null == instance) {</div><div>                instance = new JobRegistry();</div><div>            }</div><div>        }</div><div>    }</div><div>    return instance;</div><div>}</div></div><div>获取注册器实例，典型的双重判空的单例模式。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void addJobInstance(final String jobName, final JobInstance jobInstance) {</div><div>    jobInstanceMap.put(jobName, jobInstance);</div><div>}</div></div><div>第一行至此，分析完毕。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>setGuaranteeServiceForElasticJobListeners(regCenter, elasticJobListenerList);</div></div><div>函数名字起的很直白，给监听器设置保证服务的，这个GuaranteeService看了一下，主要是关于zookeeper结点和时间服务的，暂时没看出它的用处，先不细看，跳过。</div><div>后面两行造出了两个门面类，门面模式的应用，所谓门面模式，就是用一个门面封装复杂的内部实现，对外只暴露一个简洁的门面。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 为调度器提供内部服务的门面类.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>public final class SchedulerFacade </div><div><br/></div><div>/**</div><div>* 为作业提供内部服务的门面类.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>@Slf4j</div><div>public final class LiteJobFacade implements JobFacade {</div></div><div>老规矩，等用到的时候再看他们干了什么。</div><div><br/></div><div>回顾一下，构造器里面只是准备了一堆后续可能用到的对象，除此之外，就是在注册器里面注册了作业信息。注意，这注册器不是分布式的，只是的本地的注册器。</div><div><br/></div><div>4、初始化</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 初始化作业.</div><div>*/</div><div>public void init() {</div><div>    LiteJobConfiguration liteJobConfigFromRegCenter = schedulerFacade.updateJobConfiguration(liteJobConfig);</div><div>    JobRegistry.getInstance().setCurrentShardingTotalCount(liteJobConfigFromRegCenter.getJobName(), liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getShardingTotalCount());</div><div>    JobScheduleController jobScheduleController = new JobScheduleController(createScheduler(), createJobDetail(liteJobConfigFromRegCenter.getTypeConfig().getJobClass()), liteJobConfigFromRegCenter.getJobName());</div><div>    JobRegistry.getInstance().registerJob(liteJobConfigFromRegCenter.getJobName(), jobScheduleController, regCenter);</div><div>    schedulerFacade.registerStartUpInfo(!liteJobConfigFromRegCenter.isDisabled());</div><div>    jobScheduleController.scheduleJob(liteJobConfigFromRegCenter.getTypeConfig().getCoreConfig().getCron());</div><div>}</div></div><div>从调用栈挨个看下用到的主要方法</div><div>a、以下是第一行 schedulerFacade.updateJobConfiguration(liteJobConfig);的相关方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 更新作业配置.</div><div>*</div><div>* @param liteJobConfig 作业配置</div><div>* @return 更新后的作业配置</div><div>*/</div><div>public LiteJobConfiguration updateJobConfiguration(final LiteJobConfiguration liteJobConfig) {</div><div>    configService.persist(liteJobConfig);</div><div>    return configService.load(false);//load重新从zookeeper读取信息</div><div>}</div><div><br/></div><div>/**</div><div>* 持久化分布式作业配置信息.</div><div>*</div><div>* @param liteJobConfig 作业配置</div><div>*/</div><div>public void persist(final LiteJobConfiguration liteJobConfig) {</div><div>    checkConflictJob(liteJobConfig);</div><div>    //zookeeper中不存在，或者要重写zookeeper信息（构造liteJobConfig时可以指定），则覆盖zookeeper中的信息,注意，如果修改了配置信息一定要改成可以覆盖，负责更改不会生效</div><div>    if (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT) || l<font color="#BA00FF">iteJobConfig.isOverwrite()</font>) {</div><div>        jobNodeStorage.replaceJobNode(ConfigurationNode.ROOT, LiteJobConfigurationGsonFactory.toJson(liteJobConfig));</div><div>    }</div><div>}</div><div>//检查是否存在冲突的作业，如果存在作业名字相同但是作业的class不同的情况，则抛出异常</div><div>private void checkConflictJob(final LiteJobConfiguration liteJobConfig) {</div><div>    Optional&lt;LiteJobConfiguration&gt; liteJobConfigFromZk = find();</div><div>    if (liteJobConfigFromZk.isPresent() &amp;&amp; !liteJobConfigFromZk.get().getTypeConfig().getJobClass().equals(liteJobConfig.getTypeConfig().getJobClass())) {</div><div>        throw new JobConfigurationException(&quot;Job conflict with register center. The job '%s' in register center's class is '%s', your job class is '%s'&quot;,</div><div>                liteJobConfig.getJobName(), liteJobConfigFromZk.get().getTypeConfig().getJobClass(), liteJobConfig.getTypeConfig().getJobClass());</div><div>    }</div><div>}</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//查找zookeeper中的信息</span></div><div>private Optional&lt;LiteJobConfiguration&gt; find() {</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //c此处查询的是jobName/config</span></div><div>    if (!jobNodeStorage.isJobNodeExisted(ConfigurationNode.ROOT)) {</div><div>        return Optional.absent();</div><div>    }</div><div>//将zookeeper中查到的信息进行反序列化</div><div>    LiteJobConfiguration result = LiteJobConfigurationGsonFactory.fromJson(jobNodeStorage.getJobNodeDataDirectly(ConfigurationNode.ROOT));</div><div>    if (null == result) {</div><div>        // TODO 应该删除整个job node,并非仅仅删除config node</div><div>        jobNodeStorage.removeJobNodeIfExisted(ConfigurationNode.ROOT);</div><div>    }</div><div>    return Optional.fromNullable(result);</div><div>}</div></div><div><br/></div><div>config节点中的数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>{</div><div>    &quot;jobName&quot;: &quot;job1&quot;,</div><div>    &quot;jobClass&quot;: &quot;com.si.job.db.job.Job1&quot;,</div><div>    &quot;jobType&quot;: &quot;SIMPLE&quot;,</div><div>    &quot;cron&quot;: &quot;0/30 * * * * ?&quot;,</div><div>    &quot;shardingTotalCount&quot;: 1,</div><div>    &quot;shardingItemParameters&quot;: &quot;&quot;,</div><div>    &quot;jobParameter&quot;: &quot;&quot;,</div><div>    &quot;failover&quot;: false,</div><div>    &quot;misfire&quot;: true,</div><div>    &quot;description&quot;: &quot;&quot;,</div><div>    &quot;jobProperties&quot;: {</div><div>        &quot;job_exception_handler&quot;: &quot;com.dangdang.ddframe.job.executor.handler.impl.DefaultJobExceptionHandler&quot;,</div><div>        &quot;executor_service_handler&quot;: &quot;com.dangdang.ddframe.job.executor.handler.impl.DefaultExecutorServiceHandler&quot;</div><div>    },</div><div>    &quot;monitorExecution&quot;: true,</div><div>    &quot;maxTimeDiffSeconds&quot;: -1,</div><div>    &quot;monitorPort&quot;: -1,</div><div>    &quot;jobShardingStrategyClass&quot;: &quot;com.dangdang.ddframe.job.lite.api.strategy.impl.AverageAllocationJobShardingStrategy&quot;,</div><div>    &quot;reconcileIntervalMinutes&quot;: 10,</div><div>    &quot;disabled&quot;: false,</div><div>    &quot;overwrite&quot;: false</div><div>}</div></div><div><br/></div><div>b、以下是第二行 JobRegistry.getInstance().setCurrentShardingTotalCount调用的相关方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 设置当前分片总数.</div><div>*/</div><div>public void setCurrentShardingTotalCount(final String jobName, final int currentShardingTotalCount) {</div><div>    currentShardingTotalCountMap.put(jobName, currentShardingTotalCount);</div><div>}</div></div><div>c、以下是new JobScheduleController（作业调度控制器）调用，方法较多</div><div>注意，当前init方法是JobScheduler类的</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private Scheduler createScheduler() {</div><div>    Scheduler result;</div><div>    try {</div><div>        //标准调度器工厂</div><div>        StdSchedulerFactory factory = new StdSchedulerFactory();</div><div>        factory.initialize(getBaseQuartzProperties());</div><div>        //获取实例</div><div>        result = factory.getScheduler();</div><div>    } catch (final SchedulerException ex) {</div><div>        throw new JobSystemException(ex);</div><div>    }</div><div>    return result;</div><div>}</div></div><div>Scheduler是quart框架提供的接口，主要是提供一些对job作业调度的方法以及获取job信息的方法。看一下getBaseQuartzProperties</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//该方法中主要是一些quart框架要用到的配置，不做过多关注</div><div>private Properties getBaseQuartzProperties() {</div><div>    Properties result = new Properties();</div><div>    result.put(&quot;<font color="#D100FF">org.quartz.threadPool.class&quot;, org.quartz.simpl.SimpleThreadPool.class.getName(</font>));</div><div>    result.put(<font color="#9E00F3">&quot;org.quartz.threadPool.threadCount&quot;, &quot;1&quot;</font>);</div><div>    result.put(&quot;<font color="#D100FF">org.quartz.scheduler.instanceName&quot;, liteJobConfig.getJobName());</font></div><div>    result.put(&quot;org.quartz.jobStore.misfireThreshold&quot;, &quot;1&quot;);</div><div>    result.put(&quot;org.quartz.plugin.shutdownhook.class&quot;, JobShutdownHookPlugin.class.getName());</div><div>    result.put(&quot;org.quartz.plugin.shutdownhook.cleanShutdown&quot;, Boolean.TRUE.toString());</div><div>    return result;</div><div>}</div></div><div>看看从工厂获取实例的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Scheduler getScheduler() throws SchedulerException {</div><div>    if (cfg == null) {</div><div>        initialize();</div><div>    }</div><div>    //SchedulerRepository是个单例模式的，内部有个map存储所有的Scheduler</div><div>    SchedulerRepository schedRep = SchedulerRepository.getInstance();</div><div>    //lookup直接从map中取数据</div><div>    Scheduler sched = schedRep.lookup(getSchedulerName());</div><div>    //第一次时还没有往map中存过数据，显然是拿不到的</div><div>    if (sched != null) {</div><div>        if (sched.isShutdown()) {</div><div>            schedRep.remove(getSchedulerName());</div><div>        } else {</div><div>            return sched;</div><div>        }</div><div>    }</div><div>    //这个方法代码行罕见的达到了惊人的800多行，又臭又长，可以猜测主要是产生一个Scheduler对象，并将其放入map中（代码过于复杂，并未详查）</div><div>    sched = instantiate();</div><div>    return sched;</div><div>}</div></div><div>另外createJobDetail()实例化一个JobDetail（这个是接口，方法中创建的是JobDetailImpl）</div><div><br/></div><div>d、registerJob</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 添加作业调度控制器.</div><div>*</div><div>* @param jobName 作业名称</div><div>* @param jobScheduleController 作业调度控制器</div><div>* @param regCenter 注册中心</div><div>*/</div><div>public void registerJob(final String jobName, final JobScheduleController jobScheduleController, final CoordinatorRegistryCenter regCenter) {</div><div>    schedulerMap.put(jobName, jobScheduleController);</div><div>    regCenterMap.put(jobName, regCenter);</div><div>    regCenter.addCacheData(&quot;/&quot; + jobName);//缓存相关，暂时不知什么时候用到</div><div>}</div></div><div><br/></div><div>e、schedulerFacade.registerStartUpInfo</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 注册作业启动信息.</div><div>*</div><div>* @param enabled 作业是否启用</div><div>*/</div><div>public void registerStartUpInfo(final boolean enabled) {</div><div>    //启动监听器</div><div>    listenerManager.startAllListeners();</div><div>    //选举主节点</div><div>    leaderService.electLeader();</div><div>    //服务持久化</div><div>    serverService.persistOnline(enabled);</div><div>    //实例持久化</div><div>    instanceService.persistOnline();</div><div>    //设置需要重新分片的标记.</div><div>    shardingService.setReshardingFlag();</div><div>    </div><div>    monitorService.listen();</div><div>    if (!reconcileService.isRunning()) {</div><div>        reconcileService.startAsync();</div><div>    }</div><div>}</div><div>1、启动监听器</div><div>/**</div><div>* 开启所有监听器.</div><div>根据名字看一下都有哪些监听器，有个大概印象即可：选举、分片、失败转移、关闭等等</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">这里是不是可以借鉴一下spring中的写法，毕竟这么写不好扩展啊</span></div><div>*/</div><div>public void startAllListeners() {</div><div>    electionListenerManager.start();</div><div>    shardingListenerManager.start();</div><div>    failoverListenerManager.start();</div><div>    shutdownListenerManager.start();</div><div>    triggerListenerManager.start();</div><div>    rescheduleListenerManager.start();</div><div>    guaranteeListenerManager.start();</div><div>    jobNodeStorage.addConnectionStateListener(regCenterConnectionStateListener);</div><div>}</div><div><br/></div><div>2、选举主节点</div><div>/**</div><div>* 选举主节点.</div><div>*/</div><div>public void electLeader() {</div><div>    log.debug(&quot;Elect a new leader now.&quot;);</div><div>    jobNodeStorage.executeInLeader(LeaderNode.LATCH, new LeaderElectionExecutionCallback());</div><div>    log.debug(&quot;Leader election completed.&quot;);</div><div>}</div><div><br/></div><div>/**</div><div>* 在主节点执行操作.</div><div>*</div><div>* @param latchNode 分布式锁使用的作业节点名称</div><div>* @param callback 执行操作的回调</div><div>*/</div><div>public void executeInLeader(final String latchNode, final LeaderExecutionCallback callback) {</div><div>    try (LeaderLatch latch = new LeaderLatch(getClient(), jobNodePath.getFullPath(latchNode))) {</div><div>        latch.start();</div><div>        latch.await();</div><div>        callback.execute();</div><div>    //CHECKSTYLE:OFF</div><div>    } catch (final Exception ex) {</div><div>    //CHECKSTYLE:ON</div><div>        handleException(ex);</div><div>    }</div><div>}</div><div>断点看一下第二个参数latchpath的值：/job1/leader/election/latch</div><div>整个选举的过程只明白了个大概，参考：https://blog.csdn.net/qq924862077/article/details/82858694</div><div>latch.start()调用了seSet(),在上面的路径下创建临时顺序子节点，然后检测创建的顺序子节点是不是第一个，如果是第一个就把当前服务器设为主节点。否则就在其前一个结点上注册一个监听器，如果有节点删除事件，就检测自己是不是变成了主节点</div><div><br/></div><div>private void checkLeadership(List&lt;String&gt; children) throws Exception</div><div>{</div><div>    final String localOurPath = ourPath.get();</div><div>    List&lt;String&gt; sortedChildren = LockInternals.getSortedChildren(LOCK_NAME, sorter, children);</div><div>    int ourIndex = (localOurPath != null) ? sortedChildren.indexOf(ZKPaths.getNodeFromPath(localOurPath)) : -1;</div><div>    if ( ourIndex &lt; 0 )</div><div>    {</div><div>        log.error(&quot;Can't find our node. Resetting. Index: &quot; + ourIndex);</div><div>        reset();</div><div>    }</div><div>    else if ( ourIndex == 0 )</div><div>    {</div><div>        setLeadership(true);设为主节点</div><div>    }</div><div>    else</div><div>    {</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //获取前一个结点路径</span></div><div>        String watchPath = sortedChildren.get(ourIndex - 1);</div><div>        Watcher watcher = new Watcher()</div><div>        {</div><div>            @Override</div><div>            public void process(WatchedEvent event)</div><div>            {        监听节点删除事件</div><div>                if ( (state.get() == State.STARTED) &amp;&amp; (event.getType() == Event.EventType.NodeDeleted) &amp;&amp; (localOurPath != null) )</div><div>                {</div><div>                    try</div><div>                    {</div><div>                        getChildren();</div><div>                    }</div><div>                    catch ( Exception ex )</div><div>                    {</div><div>                        ThreadUtils.checkInterrupted(ex);</div><div>                        log.error(&quot;An error occurred checking the leadership.&quot;, ex);</div><div>                    }</div><div>                }</div><div>            }</div><div>        };</div><div><br/></div><div><br/></div><div>        BackgroundCallback callback = new BackgroundCallback()</div><div>        {</div><div>            @Override</div><div>            public void processResult(CuratorFramework client, CuratorEvent event) throws Exception</div><div>            {</div><div>                if ( event.getResultCode() == KeeperException.Code.NONODE.intValue() )</div><div>                {</div><div>                    // previous node is gone - reset</div><div>                    reset();</div><div>                }</div><div>            }</div><div>        };</div><div>        // use getData() instead of exists() to avoid leaving unneeded watchers which is a type of resource leak</div><div>        //把上面的监听器注册到前面一个结点上</div><div>        client.getData().usingWatcher(watcher).inBackground(callback).forPath(ZKPaths.makePath(latchPath, watchPath));</div><div>    }</div><div>}</div><div><br/></div><div>而callback用来检测自己是不是主节点</div><div>class LeaderElectionExecutionCallback implements LeaderExecutionCallback {</div><div>    </div><div>    @Override</div><div>    public void execute() {</div><div>        if (!hasLeader()) {</div><div>            //如果是主节点，则在instance路径下写下自己的服务信息（leader/election/instance）</div><div>            jobNodeStorage.fillEphemeralJobNode(LeaderNode.INSTANCE, JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId());</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div>3、服务持久化</div><div>persistOnline就是讲本服务ip信息写入zookeeper（/job1/servers/192.168.56.1）</div><div><br/></div><div>/**</div><div>* 持久化作业服务器上线信息.</div><div>*</div><div>* @param enabled 作业是否启用</div><div>*/</div><div>public void persistOnline(final boolean enabled) {</div><div>    if (!JobRegistry.getInstance().isShutdown(jobName)) {</div><div>        jobNodeStorage.fillJobNode(serverNode.getServerNode(JobRegistry.getInstance().getJobInstance(jobName).getIp()), enabled ? &quot;&quot; : ServerStatus.DISABLED.name());</div><div>    }</div><div>}</div><div>/**</div><div>* 填充节点数据.</div><div>*</div><div>* @param node 作业节点名称</div><div>* @param value 作业节点数据值</div><div>*/</div><div>public void fillJobNode(final String node, final Object value) {</div><div>    regCenter.persist(jobNodePath.getFullPath(node), value.toString());</div><div>}</div><div><br/></div><div>4、实例持久化</div><div>此时写的是临时节点：/job1/instances/192.168.56.1@-@ec237342-9432-4a03-af4b-185499aaa3fd</div><div><br/></div><div>/**</div><div>* 持久化作业运行实例上线相关信息.</div><div>*/</div><div>public void persistOnline() {</div><div>    jobNodeStorage.fillEphemeralJobNode(instanceNode.getLocalInstanceNode(), &quot;&quot;);</div><div>}</div><div><br/></div><div>5、设置需要重新分片的标记.</div><div><br/></div><div>/**</div><div>* 设置需要重新分片的标记.</div><div>*/</div><div>public void setReshardingFlag() {</div><div>    jobNodeStorage.createJobNodeIfNeeded(ShardingNode.NECESSARY);</div><div>}</div><div><br/></div><div>/**</div><div>* 如果存在则创建作业节点.</div><div>*</div><div>* &lt;p&gt;如果作业根节点不存在表示作业已经停止, 不再继续创建节点.&lt;/p&gt;</div><div>*</div><div>* @param node 作业节点名称</div><div>isJobRootNodeExisted判断的路径就是作业名称:job1</div><div>isJobNodeExisted判断的路径：/job1/leader/sharding/necessary</div><div>*/</div><div>public void createJobNodeIfNeeded(final String node) {</div><div>    if (isJobRootNodeExisted() &amp;&amp; !isJobNodeExisted(node)) {</div><div>        regCenter.persist(jobNodePath.getFullPath(node), &quot;&quot;);</div><div>    }</div><div>}</div></div><div>f、scheduleJob作业调度</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 调度作业.</div><div>*</div><div>* @param cron CRON表达式</div><div>*/</div><div>public void scheduleJob(final String cron) {</div><div>    try {</div><div>        //是否被调度过</div><div>        if (!scheduler.checkExists(jobDetail.getKey())) {</div><div>            //jobDetail 里面是作业信息</div><div>            //createTrigger 将cron表达式封装成CronTrigger对象</div><div>            //把这两个信息存储到jobStore中</div><div>            scheduler.scheduleJob(jobDetail, createTrigger(cron));</div><div>        }</div><div>        scheduler.start();</div><div>    } catch (final SchedulerException ex) {</div><div>        throw new JobSystemException(ex);</div><div>    }</div><div>}</div><div><br/></div><div>//QuartzScheduler类的方法</div><div>public void start() throws SchedulerException {</div><div>    if (shuttingDown|| closed) {</div><div>        throw new SchedulerException(</div><div>                &quot;The Scheduler cannot be restarted after shutdown() has been called.&quot;);</div><div>    }</div><div><br/></div><div>    // QTZ-212 : calling new schedulerStarting() method on the listeners</div><div>    // right after entering start()</div><div>    notifySchedulerListenersStarting();</div><div><br/></div><div>    if (initialStart == null) {</div><div>        initialStart = new Date();</div><div>        //跟踪代码，发现调用RAMJobStore.schedulerStarted()方法，但是该方法是空方法，没有任何代码，开始懵逼到底是怎么调度的（后补下面5调度线程启动以及下一篇quartz调度过程）</div><div>        this.resources.getJobStore().schedulerStarted();            </div><div>        startPlugins();</div><div>    } else {</div><div>        resources.getJobStore().schedulerResumed();</div><div>    }</div><div>    schedThread.togglePause(false);</div><div>    getLog().info(&quot;Scheduler &quot; + resources.getUniqueIdentifier() + &quot; started.&quot;);</div><div>    notifySchedulerListenersStarted();</div><div>}</div></div><div><br/></div><div>5、调度线程启动</div><div>JobScheduler.init()</div><div>    -&gt;createScheduler()</div><div>        -&gt;StdSchedulerFactory.getScheduler()</div><div>            -&gt;StdSchedulerFactory.instantiate()</div><div>                -&gt;1311 新建了SimpleThreadPool,执行其initialize</div><div>                -&gt;1322 new QuartzScheduler()</div><div>                    -&gt;new QuartzSchedulerThread,生成对象后，新建一个线程执行run</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 