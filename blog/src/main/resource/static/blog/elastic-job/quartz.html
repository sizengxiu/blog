<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="485"/>

<div>
<span><div><div><div>elastic-job是基于quartz的二次封装。感谢： <a href="https://www.cnblogs.com/liuroy/p/7517777.html">https://www.cnblogs.com/liuroy/p/7517777.html</a></div><div><br/></div><div>1、涉及到的类</div><div>QuartzSchedulerThread、SimpleThreadPool、WorkerThread、JobRunShell</div><div><br/></div><div>QuartzSchedulerThread的方法实体</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>@Override</div><div>public void run() {</div><div>    int acquiresFailed = 0;</div><div>    while (!halted.get()) {</div><div>        try {</div><div>第一段</div><div>            // check if we're supposed to pause...</div><div>            synchronized (sigLock) {</div><div>                while (paused &amp;&amp; !halted.get()) {</div><div>                    try {</div><div>                        //如果有任务调度变更，会收到通知</div><div>                        // wait until togglePause(false) is called...</div><div>                        sigLock.wait(1000L);</div><div>                    } catch (InterruptedException ignore) {</div><div>                    }</div><div>                    // reset failure counter when paused, so that we don't</div><div>                    // wait again after unpausing</div><div>                    acquiresFailed = 0;</div><div>                }</div><div><br/></div><div><br/></div><div>                if (halted.get()) {</div><div>                    break;</div><div>                }</div><div>            }</div><div><br/></div><div>第二段</div><div>            // wait a bit, if reading from job store is consistently</div><div>            // failing (e.g. DB is down or restarting)..</div><div>            if (acquiresFailed &gt; 1) {</div><div>                try {</div><div>                    long delay = computeDelayForRepeatedErrors(qsRsrcs.getJobStore(), acquiresFailed);</div><div>                    Thread.sleep(delay);</div><div>                } catch (Exception ignore) {</div><div>                }</div><div>            }</div><div><br/></div><div>第三段</div><div>            int availThreadCount = qsRsrcs.getThreadPool().blockForAvailableThreads();//可用线程数（一定&gt;1）</div><div>            if(availThreadCount &gt; 0) { // will always be true, due to semantics of blockForAvailableThreads...</div><div><br/></div><div><br/></div><div>                List&lt;OperableTrigger&gt; triggers;</div><div><br/></div><div><br/></div><div>                long now = System.currentTimeMillis();</div><div><br/></div><div>                //清除可能存在的调度变更通知</div><div>                clearSignaledSchedulingChange();</div><div>                try {</div><div>第四段               获取下一轮有激活任务的触发器</div><div>                    triggers = qsRsrcs.getJobStore().acquireNextTriggers(</div><div>                            now + idleWaitTime, Math.min(availThreadCount, qsRsrcs.getMaxBatchSize()), qsRsrcs.getBatchTimeWindow());</div><div>                    acquiresFailed = 0;</div><div>                    if (log.isDebugEnabled())</div><div>                        log.debug(&quot;batch acquisition of &quot; + (triggers == null ? 0 : triggers.size()) + &quot; triggers&quot;);</div><div>                } catch (JobPersistenceException jpe) {</div><div>                    if (acquiresFailed == 0) {</div><div>                        qs.notifySchedulerListenersError(</div><div>                            &quot;An error occurred while scanning for the next triggers to fire.&quot;,</div><div>                            jpe);</div><div>                    }</div><div>                    if (acquiresFailed &lt; Integer.MAX_VALUE)</div><div>                        acquiresFailed++;</div><div>                    continue;</div><div>                } catch (RuntimeException e) {</div><div>                    if (acquiresFailed == 0) {</div><div>                        getLog().error(&quot;quartzSchedulerThreadLoop: RuntimeException &quot;</div><div>                                +e.getMessage(), e);</div><div>                    }</div><div>                    if (acquiresFailed &lt; Integer.MAX_VALUE)</div><div>                        acquiresFailed++;</div><div>                    continue;</div><div>                }</div><div><br/></div><div>第五段</div><div>                if (triggers != null &amp;&amp; !triggers.isEmpty()) {</div><div>                    now = System.currentTimeMillis();</div><div>                    long triggerTime = triggers.get(0).getNextFireTime().getTime();</div><div>                    //距离下次激活作业的时间间隔</div><div>                    long timeUntilTrigger = triggerTime - now;</div><div>                    while(timeUntilTrigger &gt; 2) {</div><div>                        synchronized (sigLock) {</div><div>                            if (halted.get()) {</div><div>                                break;</div><div>                            }</div><div>                            //判断是否有比这个trigger激活时间还早的trigger</div><div>                            if (!isCandidateNewTimeEarlierWithinReason(triggerTime, false)) {</div><div>                                try {</div><div>                                    // we could have blocked a long while</div><div>                                    // on 'synchronize', so we must recompute</div><div>                                    now = System.currentTimeMillis();</div><div>                                    timeUntilTrigger = triggerTime - now;//计算到触发时间的时长</div><div>                                    if(timeUntilTrigger &gt;= 1)</div><div>                                        sigLock.wait(timeUntilTrigger);//一致等待直到触发时间</div><div>                                } catch (InterruptedException ignore) {</div><div>                                }</div><div>                            }</div><div>                        }</div><div>第六段</div><div>                        //如果是被notify唤醒，会清空triggers列表</div><div>                        if(releaseIfScheduleChangedSignificantly(triggers, triggerTime)) {</div><div>                            break;</div><div>                        }</div><div>                        now = System.currentTimeMillis();</div><div>                        timeUntilTrigger = triggerTime - now;</div><div>                    }</div><div><br/></div><div>                   // 判断此列表为空，重新进入下一次循环，重新计算激活列表（因为是被notify,说明任务调度有变更，所以要重新计算）</div><div>                    // this happens if releaseIfScheduleChangedSignificantly decided to release triggers</div><div>                    if(triggers.isEmpty())</div><div>                        continue;</div><div><br/></div><div><br/></div><div>                    // set triggers to 'executing'</div><div>                    List&lt;TriggerFiredResult&gt; bndles = new ArrayList&lt;TriggerFiredResult&gt;();</div><div><br/></div><div><br/></div><div>                    boolean goAhead = true;</div><div>                    synchronized(sigLock) {</div><div>                        goAhead = !halted.get();</div><div>                    }</div><div>第七段</div><div>                    if(goAhead) {</div><div>                        try {</div><div>                            //将作业状态由STATE_ACQUIRED变更为STATE_WAITING，把不允许并发执行的放入blockedJobs集合中</div><div>                            List&lt;TriggerFiredResult&gt; res = qsRsrcs.getJobStore().triggersFired(triggers);</div><div>                            if(res != null)</div><div>                                bndles = res;</div><div>                        } catch (SchedulerException se) {</div><div>                            qs.notifySchedulerListenersError(</div><div>                                    &quot;An error occurred while firing triggers '&quot;</div><div>                                            + triggers + &quot;'&quot;, se);</div><div>                            //QTZ-179 : a problem occurred interacting with the triggers from the db</div><div>                            //we release them and loop again</div><div>                            for (int i = 0; i &lt; triggers.size(); i++) {</div><div>                                qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</div><div>                            }</div><div>                            continue;</div><div>                        }</div><div><br/></div><div><br/></div><div>                    }</div><div><br/></div><div><br/></div><div>                    for (int i = 0; i &lt; bndles.size(); i++) {</div><div>                        TriggerFiredResult result =  bndles.get(i);</div><div>                        TriggerFiredBundle bndle =  result.getTriggerFiredBundle();</div><div>                        Exception exception = result.getException();</div><div><br/></div><div><br/></div><div>                        if (exception instanceof RuntimeException) {</div><div>                            getLog().error(&quot;RuntimeException while firing trigger &quot; + triggers.get(i), exception);</div><div>                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</div><div>                            continue;</div><div>                        }</div><div><br/></div><div><br/></div><div>                        // it's possible to get 'null' if the triggers was paused,</div><div>                        // blocked, or other similar occurrences that prevent it being</div><div>                        // fired at this time...  or if the scheduler was shutdown (halted)</div><div>                        if (bndle == null) {</div><div>                            qsRsrcs.getJobStore().releaseAcquiredTrigger(triggers.get(i));</div><div>                            continue;</div><div>                        }</div><div><br/></div><div>第八段</div><div>                        JobRunShell shell = null;</div><div>                        try {</div><div>                            //实例化一个JobRunShell对象，它实现了Runable接口，是个线程</div><div>                            shell = qsRsrcs.getJobRunShellFactory().createJobRunShell(bndle);</div><div>                            //内部构造一个JobExecutionContextImpl对象</div><div>                            shell.initialize(qs);</div><div>                        } catch (SchedulerException se) {</div><div>                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</div><div>                            continue;</div><div>                        }</div><div><br/></div><div><br/></div><div>                        if (qsRsrcs.getThreadPool().runInThread(shell) == false) {</div><div>                            // this case should never happen, as it is indicative of the</div><div>                            // scheduler being shutdown or a bug in the thread pool or</div><div>                            // a thread pool being used concurrently - which the docs</div><div>                            // say not to do...</div><div>                            getLog().error(&quot;ThreadPool.runInThread() return false!&quot;);</div><div>                            qsRsrcs.getJobStore().triggeredJobComplete(triggers.get(i), bndle.getJobDetail(), CompletedExecutionInstruction.SET_ALL_JOB_TRIGGERS_ERROR);</div><div>                        }</div><div><br/></div><div><br/></div><div>                    }</div><div><br/></div><div><br/></div><div>                    continue; // while (!halted)</div><div>                }</div><div>            } else { // if(availThreadCount &gt; 0)</div><div>                // should never happen, if threadPool.blockForAvailableThreads() follows contract</div><div>                continue; // while (!halted)</div><div>            }</div><div><br/></div><div><br/></div><div>            long now = System.currentTimeMillis();</div><div>            long waitTime = now + getRandomizedIdleWaitTime();</div><div>            long timeUntilContinue = waitTime - now;</div><div>            synchronized(sigLock) {</div><div>                try {</div><div>                  if(!halted.get()) {</div><div>                    // QTZ-336 A job might have been completed in the mean time and we might have</div><div>                    // missed the scheduled changed signal by not waiting for the notify() yet</div><div>                    // Check that before waiting for too long in case this very job needs to be</div><div>                    // scheduled very soon</div><div>                    if (!isScheduleChanged()) {</div><div>                      sigLock.wait(timeUntilContinue);</div><div>                    }</div><div>                  }</div><div>                } catch (InterruptedException ignore) {</div><div>                }</div><div>            }</div><div><br/></div><div><br/></div><div>        } catch(RuntimeException re) {</div><div>            getLog().error(&quot;Runtime error occurred in main trigger firing loop.&quot;, re);</div><div>        }</div><div>    } // while (!halted)</div><div><br/></div><div><br/></div><div>    // drop references to scheduler stuff to aid garbage collection...</div><div>    qs = null;</div><div>    qsRsrcs = null;</div><div>}</div><div><br/></div></div><div>第一段</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/** 添加任务时会在Schedule.start中调用该方法，通知主线程调度变更</div><div>* &lt;p&gt;</div><div>* Signals the main processing loop to pause at the next possible point.</div><div>* &lt;/p&gt;</div><div>*/</div><div>void togglePause(boolean pause) {</div><div>    synchronized (sigLock) {</div><div>        paused = pause;</div><div>        if (paused) {</div><div>            signalSchedulingChange(0);</div><div>        } else {</div><div>            sigLock.notifyAll();</div><div>        }</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>/**</div><div>* &lt;p&gt;通知主线程调度变更（主线程在等待下次激活时间到达，在循环中睡眠）</div><div>* Signals the main processing loop that a change in scheduling has been</div><div>* made - in order to interrupt any sleeping that may be occuring while</div><div>* waiting for the fire time to arrive.</div><div>* &lt;/p&gt;</div><div>*</div><div>* @param candidateNewNextFireTime the time (in millis) when the newly scheduled trigger</div><div>* will fire.  If this method is being called do to some other even (rather</div><div>* than scheduling a trigger), the caller should pass zero (0).</div><div>*/</div><div>public void signalSchedulingChange(long candidateNewNextFireTime) {</div><div>    synchronized(sigLock) {</div><div>        signaled = true;</div><div>        signaledNextFireTime = candidateNewNextFireTime;</div><div>        sigLock.notifyAll();</div><div>    }</div><div>}</div></div><div><br/></div><div>第三段</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>阻塞等待可用线程</div><div>public int blockForAvailableThreads() {</div><div>    synchronized(nextRunnableLock) {</div><div>        //循环等待，直到有可用线程</div><div>        while((availWorkers.size() &lt; 1 || handoffPending) &amp;&amp; !isShutdown) {</div><div>            try {</div><div>                nextRunnableLock.wait(500);</div><div>            } catch (InterruptedException ignore) {</div><div>            }</div><div>        }</div><div>        return availWorkers.size();//可用线程数量</div><div>    }</div><div>}</div></div><div><br/></div><div>第四段</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* &lt;p&gt;</div><div>* Get a handle to the next trigger to be fired, and mark it as 'reserved'</div><div>* by the calling scheduler.最终返回的是在允许过期且在最大空闲等待时间内的触发器</div><div>* &lt;/p&gt;</div><div>*</div><div>* @see #releaseAcquiredTrigger(OperableTrigger)</div><div>*/</div><div>public List&lt;OperableTrigger&gt; acquireNextTriggers(long noLaterThan, int maxCount, long timeWindow) {</div><div>    synchronized (lock) {</div><div>        List&lt;OperableTrigger&gt; result = new ArrayList&lt;OperableTrigger&gt;();</div><div>        Set&lt;JobKey&gt; acquiredJobKeysForNoConcurrentExec = new HashSet&lt;JobKey&gt;();</div><div>        Set&lt;TriggerWrapper&gt; excludedTriggers = new HashSet&lt;TriggerWrapper&gt;();</div><div>        long batchEnd = noLaterThan;//当前时间加上最大空闲等待时间（默认值是30秒）</div><div>        </div><div>        // return empty list if store has no triggers.</div><div>        if (timeTriggers.size() == 0)</div><div>            return result;</div><div>        </div><div>        while (true) {</div><div>            TriggerWrapper tw;</div><div>            try {</div><div>                tw = timeTriggers.first();//获取第一个触发器</div><div>                if (tw == null)</div><div>                    break;</div><div>                timeTriggers.remove(tw);//并从map中移除（后续再加入，是为了获得时间排序）</div><div>            } catch (java.util.NoSuchElementException nsee) {</div><div>                break;</div><div>            }</div><div><br/></div><div>            if (tw.trigger.getNextFireTime() == null) {</div><div>                continue;</div><div>            }</div><div><br/></div><div>            //如果下一次的激活时间有变化(下次时间超过允许的过期时间)，则将触发器重新存入treeMap</div><div>            if (applyMisfire(tw)) {</div><div>                if (tw.trigger.getNextFireTime() != null) {</div><div>                    timeTriggers.add(tw);</div><div>                }</div><div>                continue;</div><div>            }</div><div>            //如果下次激活时间还未到达最大空闲等待时间，存入treeMap</div><div>            if (tw.getTrigger().getNextFireTime().getTime() &gt; batchEnd) {</div><div>                timeTriggers.add(tw);</div><div>                break;</div><div>            }</div><div>            </div><div>            // If trigger's job is set as @DisallowConcurrentExecution, and it has already been added to result, then</div><div>            // put it back into the timeTriggers set and continue to search for next trigger.</div><div>            JobKey jobKey = tw.trigger.getJobKey();</div><div>            JobDetail job = jobsByKey.get(tw.trigger.getJobKey()).jobDetail;</div><div>            //作业是否允许并发执行 ，参考https://blog.csdn.net/fly_captain/article/details/83029440</div><div>            if (job.isConcurrentExectionDisallowed()) {</div><div>                //是否已经在不允许并发执行的集合中，</div><div>                //第一次遍历不在，会被加到result中；第二次遍历时，已经存在，存入excludedTriggers集合，</div><div>                </div><div>                if (acquiredJobKeysForNoConcurrentExec.contains(jobKey)) {</div><div>                    excludedTriggers.add(tw);</div><div>                    continue; // go to next trigger in store.</div><div>                } else {</div><div>                    acquiredJobKeysForNoConcurrentExec.add(jobKey);</div><div>                }</div><div>            }</div><div><br/></div><div><br/></div><div>            tw.state = TriggerWrapper.STATE_ACQUIRED;</div><div>            tw.trigger.setFireInstanceId(getFiredTriggerRecordId());</div><div>            OperableTrigger trig = (OperableTrigger) tw.trigger.clone();</div><div>            if (result.isEmpty()) {</div><div>                batchEnd = Math.max(tw.trigger.getNextFireTime().getTime(), System.currentTimeMillis()) + timeWindow;</div><div>            }</div><div>            result.add(trig);</div><div>            if (result.size() == maxCount)</div><div>                break;</div><div>        }</div><div><br/></div><div><br/></div><div>        // If we did excluded triggers to prevent ACQUIRE state due to DisallowConcurrentExecution, we need to add them back to store.</div><div>        if (excludedTriggers.size() &gt; 0)</div><div>            timeTriggers.addAll(excludedTriggers);//excludedTriggers最终又被加回timeTriggers</div><div>        return result;</div><div>    }</div><div>}</div><div><br/></div><div>这个timeTrigger是个TreeMap,并传入了一个比较器，从下面的compare方法中可以看出，TreeMap中数据的排序是nextFireTime,如果相等，则比较优先级</div><div>protected TreeSet&lt;TriggerWrapper&gt; timeTriggers = new TreeSet&lt;TriggerWrapper&gt;(new TriggerWrapperComparator());</div><div><br/></div><div>class TriggerTimeComparator implements Comparator&lt;Trigger&gt;, Serializable {</div><div>    private static final long serialVersionUID = -3904243490805975570L;</div><div>    // This static method exists for comparator in TC clustered quartz</div><div>    public static int compare(Date nextFireTime1, int priority1, TriggerKey key1, Date nextFireTime2, int priority2, TriggerKey key2) {</div><div>        if (nextFireTime1 != null || nextFireTime2 != null) {</div><div>            if (nextFireTime1 == null) {</div><div>                return 1;</div><div>            }</div><div><br/></div><div>            if (nextFireTime2 == null) {</div><div>                return -1;</div><div>            }</div><div><br/></div><div>            if(nextFireTime1.before(nextFireTime2)) {</div><div>                return -1;</div><div>            }</div><div><br/></div><div>            if(nextFireTime1.after(nextFireTime2)) {</div><div>                return 1;</div><div>            }</div><div>        }</div><div><br/></div><div>        int comp = priority2 - priority1;</div><div>        if (comp != 0) {</div><div>            return comp;</div><div>        }</div><div>        return key1.compareTo(key2);</div><div>    }</div><div>    public int compare(Trigger t1, Trigger t2) {</div><div>        return compare(t1.getNextFireTime(), t1.getPriority(), t1.getKey(), t2.getNextFireTime(), t2.getPriority(), t2.getKey());</div><div>    }</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>protected boolean applyMisfire(TriggerWrapper tw) {</div><div>    long misfireTime = System.currentTimeMillis();</div><div>    //elasticjob设置的默认值是1，单位是毫秒，也就是说，超过作业预期执行时间1ms以内的才会被执行，这个值这么小基本排除了作业错过之后重新执行的可能</div><div>    if (getMisfireThreshold() &gt; 0) {</div><div>        misfireTime -= getMisfireThreshold();</div><div>    }</div><div>    Date tnft = tw.trigger.getNextFireTime();</div><div>    //如果下个激活时间大于过期时间，不用变化直接返回</div><div>    if (tnft == null || tnft.getTime() &gt; misfireTime</div><div>            || tw.trigger.getMisfireInstruction() == Trigger.MISFIRE_INSTRUCTION_IGNORE_MISFIRE_POLICY) {</div><div>        return false;</div><div>    }</div><div><br/></div><div><br/></div><div>    Calendar cal = null;</div><div>    if (tw.trigger.getCalendarName() != null) {</div><div>        cal = retrieveCalendar(tw.trigger.getCalendarName());</div><div>    }</div><div><br/></div><div>    signaler.notifyTriggerListenersMisfired((OperableTrigger)tw.trigger.clone());</div><div>    //重新计算下一个激活时间</div><div>    tw.trigger.updateAfterMisfire(cal);</div><div><br/></div><div>    if (tw.trigger.getNextFireTime() == null) {</div><div>        tw.state = TriggerWrapper.STATE_COMPLETE;</div><div>        signaler.notifySchedulerListenersFinalized(tw.trigger);</div><div>        synchronized (lock) {</div><div>            timeTriggers.remove(tw);</div><div>        }</div><div>    } else if (tnft.equals(tw.trigger.getNextFireTime())) {</div><div>        return false;</div><div>    }</div><div><br/></div><div>    return true;</div><div>}</div></div><div><br/></div><div>第五段</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private boolean isCandidateNewTimeEarlierWithinReason(long oldTime, boolean clearSignal) {</div><div>    synchronized(sigLock) {</div><div>        //只有调度任务发生变化的时候，才会有比当前trigger激活时间早的</div><div>        if (!isScheduleChanged())</div><div>            return false;</div><div>        boolean earlier = false;</div><div>        if(getSignaledNextFireTime() == 0)</div><div>            earlier = true;</div><div>        else if(getSignaledNextFireTime() &lt; oldTime )</div><div>            earlier = true;</div><div>        if(earlier) {</div><div>            // so the new time is considered earlier, but is it enough earlier?</div><div>            long diff = oldTime - System.currentTimeMillis();</div><div>            if(diff &lt; (qsRsrcs.getJobStore().supportsPersistence() ? 70L : 7L))</div><div>                earlier = false;</div><div>        }</div><div>        if(clearSignal) {</div><div>            clearSignaledSchedulingChange();</div><div>        }</div><div>        return earlier;</div><div>    }</div><div>}</div><div>public boolean isScheduleChanged() {</div><div>    synchronized(sigLock) {</div><div>        return signaled;</div><div>    }</div><div>}</div><div>public long getSignaledNextFireTime() {</div><div>    synchronized(sigLock) {</div><div>        return signaledNextFireTime;</div><div>    }</div><div>}</div><div>public void clearSignaledSchedulingChange() {</div><div>    synchronized(sigLock) {</div><div>        signaled = false;</div><div>        signaledNextFireTime = 0;</div><div>    }</div><div>}</div></div><div>第六段</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private boolean releaseIfScheduleChangedSignificantly(</div><div>        List&lt;OperableTrigger&gt; triggers, long triggerTime) {</div><div>    //是否是被其他线程notifiy而唤醒的</div><div>    if (isCandidateNewTimeEarlierWithinReason(triggerTime, true)) {</div><div>        // above call does a clearSignaledSchedulingChange()</div><div>        for (OperableTrigger trigger : triggers) {</div><div>            //把trigger重新放回treeMap </div><div>            qsRsrcs.getJobStore().releaseAcquiredTrigger(trigger);</div><div>        }</div><div>        triggers.clear();//清空待触发列表,后续判断此列表为空，会跳过后续代码，重新进入下一次循环，重新计算激活列表（因为是被notify,说明任务调度有变更，所以要重新计算）</div><div>        return true;</div><div>    }</div><div>    return false;</div><div>}</div><div><br/></div><div>/**</div><div>* &lt;p&gt;</div><div>* Inform the &lt;code&gt;JobStore&lt;/code&gt; that the scheduler no longer plans to</div><div>* fire the given &lt;code&gt;Trigger&lt;/code&gt;, that it had previously acquired</div><div>* (reserved).</div><div>* &lt;/p&gt;</div><div>*/</div><div>public void releaseAcquiredTrigger(OperableTrigger trigger) {</div><div>    synchronized (lock) {</div><div>        TriggerWrapper tw = triggersByKey.get(trigger.getKey());</div><div>        if (tw != null &amp;&amp; tw.state == TriggerWrapper.STATE_ACQUIRED) {</div><div>            tw.state = TriggerWrapper.STATE_WAITING;</div><div>            timeTriggers.add(tw);</div><div>        }</div><div>    }</div><div>}</div></div><div>第七段</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* &lt;p&gt;</div><div>* Inform the &lt;code&gt;JobStore&lt;/code&gt; that the scheduler is now firing the</div><div>* given &lt;code&gt;Trigger&lt;/code&gt; (executing its associated &lt;code&gt;Job&lt;/code&gt;),</div><div>* that it had previously acquired (reserved).</div><div>* &lt;/p&gt;</div><div>*/</div><div>public List&lt;TriggerFiredResult&gt; triggersFired(List&lt;OperableTrigger&gt; firedTriggers) {</div><div>    synchronized (lock) {</div><div>        List&lt;TriggerFiredResult&gt; results = new ArrayList&lt;TriggerFiredResult&gt;();</div><div>        for (OperableTrigger trigger : firedTriggers) {</div><div>            TriggerWrapper tw = triggersByKey.get(trigger.getKey());</div><div>            // was the trigger deleted since being acquired?</div><div>            if (tw == null || tw.trigger == null) {</div><div>                continue;</div><div>            }</div><div>            //只要状态为STATE_ACQUIRED</div><div>            // was the trigger completed, paused, blocked, etc. since being acquired?</div><div>            if (tw.state != TriggerWrapper.STATE_ACQUIRED) {</div><div>                continue;</div><div>            }</div><div><br/></div><div><br/></div><div>            Calendar cal = null;</div><div>            if (tw.trigger.getCalendarName() != null) {</div><div>                cal = retrieveCalendar(tw.trigger.getCalendarName());</div><div>                if(cal == null)</div><div>                    continue;</div><div>            }</div><div>            Date prevFireTime = trigger.getPreviousFireTime();</div><div>            // in case trigger was replaced between acquiring and firing</div><div>            //先清除</div><div>            timeTriggers.remove(tw);</div><div>            // call triggered on our copy, and the scheduler's copy</div><div>            tw.trigger.triggered(cal);</div><div>            trigger.triggered(cal);</div><div>            //tw.state = TriggerWrapper.STATE_EXECUTING;</div><div>            tw.state = TriggerWrapper.STATE_WAITING;</div><div><br/></div><div><br/></div><div>            TriggerFiredBundle bndle = new TriggerFiredBundle(retrieveJob(</div><div>                    tw.jobKey), trigger, cal,</div><div>                    false, new Date(), trigger.getPreviousFireTime(), prevFireTime,</div><div>                    trigger.getNextFireTime());</div><div><br/></div><div><br/></div><div>            JobDetail job = bndle.getJobDetail();</div><div><br/></div><div>            if (job.isConcurrentExectionDisallowed()) {</div><div>                ArrayList&lt;TriggerWrapper&gt; trigs = getTriggerWrappersForJob(job.getKey());</div><div>                for (TriggerWrapper ttw : trigs) {</div><div>                    if (ttw.state == TriggerWrapper.STATE_WAITING) {</div><div>                        ttw.state = TriggerWrapper.STATE_BLOCKED;</div><div>                    }</div><div>                    if (ttw.state == TriggerWrapper.STATE_PAUSED) {</div><div>                        ttw.state = TriggerWrapper.STATE_PAUSED_BLOCKED;</div><div>                    }</div><div>                    timeTriggers.remove(ttw);</div><div>                }</div><div>                blockedJobs.add(job.getKey());//不允许并发的放入blockedJobs</div><div>            } else if (tw.trigger.getNextFireTime() != null) {</div><div>                synchronized (lock) {</div><div>                    timeTriggers.add(tw);//正常的trigger再被重新放回</div><div>                }</div><div>            }</div><div>            results.add(new TriggerFiredResult(bndle));</div><div>        }</div><div>        return results;</div><div>    }</div><div>}</div></div><div>第八段</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>构造一个JobRunShell实例</div><div>public JobRunShell(Scheduler scheduler, TriggerFiredBundle bndle) {</div><div>    this.scheduler = scheduler;</div><div>    this.firedTriggerBundle = bndle;</div><div>}</div><div><br/></div><div>public void initialize(QuartzScheduler sched)</div><div>    throws SchedulerException {</div><div>    this.qs = sched;</div><div><br/></div><div><br/></div><div>    Job job = null;</div><div>    JobDetail jobDetail = firedTriggerBundle.getJobDetail();</div><div><br/></div><div><br/></div><div>    try {</div><div>        //构造一个job对象</div><div>        job = sched.getJobFactory().newJob(firedTriggerBundle, scheduler);</div><div>    } catch (SchedulerException se) {</div><div>        sched.notifySchedulerListenersError(</div><div>                &quot;An error occured instantiating job to be executed. job= '&quot;</div><div>                        + jobDetail.getKey() + &quot;'&quot;, se);</div><div>        throw se;</div><div>    } catch (Throwable ncdfe) { // such as NoClassDefFoundError</div><div>        SchedulerException se = new SchedulerException(</div><div>                &quot;Problem instantiating class '&quot;</div><div>                        + jobDetail.getJobClass().getName() + &quot;' - &quot;, ncdfe);</div><div>        sched.notifySchedulerListenersError(</div><div>                &quot;An error occured instantiating job to be executed. job= '&quot;</div><div>                        + jobDetail.getKey() + &quot;'&quot;, se);</div><div>        throw se;</div><div>    }</div><div><br/></div><div>    //构造一个JobExecutionContextImpl对象</div><div>    this.jec = new JobExecutionContextImpl(scheduler, firedTriggerBundle, job);</div><div>}</div><div><br/></div><div>public boolean runInThread(Runnable runnable) {</div><div>    if (runnable == null) {</div><div>        return false;</div><div>    }</div><div>    synchronized (nextRunnableLock) {</div><div>        handoffPending = true;</div><div>        //循环等待直到可用线程队列里有可用线程</div><div>        // Wait until a worker thread is available</div><div>        while ((availWorkers.size() &lt; 1) &amp;&amp; !isShutdown) {</div><div>            try {</div><div>                nextRunnableLock.wait(500);</div><div>            } catch (InterruptedException ignore) {</div><div>            }</div><div>        }</div><div><br/></div><div>        if (!isShutdown) {</div><div>            //从可用线程队列中拿出一个可用线程，和传入的线程绑定，加入忙碌线程队列</div><div><b>        <font color="#FA7A00">    WorkerThread wt = (WorkerThread)availWorkers.removeFirst();</font></b></div><div><b><font color="#FA7A00">            busyWorkers.add(wt);</font></b></div><div>            wt.run(runnable);</div><div>        } else {</div><div>            // If the thread pool is going down, execute the Runnable</div><div>            // within a new additional worker thread (no thread from the pool).</div><div>            WorkerThread wt = new WorkerThread(this, threadGroup,</div><div>                    &quot;WorkerThread-LastJob&quot;, prio, isMakeThreadsDaemons(), runnable);</div><div>            busyWorkers.add(wt);</div><div>            workers.add(wt);</div><div>            wt.start();</div><div>        }</div><div>        nextRunnableLock.notifyAll();</div><div>        handoffPending = false;</div><div>    }</div><div><br/></div><div><br/></div><div>    return true;</div><div>}</div></div><div><br/></div><div>2、启动工作线程</div><div>    前面代码只是看到在循环中不停的检测有没有到执行时间的job，有的话就将它放入工作线程队列，但是没有看到线程工作队列中线程的启动。经过查找，在SimpleThreadPool的initialize()方法中看到了相关过程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void initialize() throws SchedulerConfigException {</div><div>    if(workers != null &amp;&amp; workers.size() &gt; 0) // already initialized...</div><div>        return;</div><div>    if (count &lt;= 0) {</div><div>        throw new SchedulerConfigException(</div><div>                &quot;Thread count must be &gt; 0&quot;);</div><div>    }</div><div>    if (prio &lt;= 0 || prio &gt; 9) {</div><div>        throw new SchedulerConfigException(</div><div>                &quot;Thread priority must be &gt; 0 and &lt;= 9&quot;);</div><div>    }</div><div><br/></div><div>    //线程组相关</div><div>    if(isThreadsInheritGroupOfInitializingThread()) {</div><div>        threadGroup = Thread.currentThread().getThreadGroup();</div><div>    } else {</div><div>        // follow the threadGroup tree to the root thread group.</div><div>        threadGroup = Thread.currentThread().getThreadGroup();</div><div>        ThreadGroup parent = threadGroup;</div><div>        while ( !parent.getName().equals(&quot;main&quot;) ) {</div><div>            threadGroup = parent;</div><div>            parent = threadGroup.getParent();</div><div>        }</div><div>        threadGroup = new ThreadGroup(parent, schedulerInstanceName + &quot;-SimpleThreadPool&quot;);</div><div>        if (isMakeThreadsDaemons()) {</div><div>            threadGroup.setDaemon(true);</div><div>        }</div><div>    }</div><div><br/></div><div>    if (isThreadsInheritContextClassLoaderOfInitializingThread()) {</div><div>        getLog().info(</div><div>                &quot;Job execution threads will use class loader of thread: &quot;</div><div>                        + Thread.currentThread().getName());</div><div>    }</div><div>     //创建线程，启动，并加入availWorkers队列</div><div>    // create the worker threads and start them</div><div>    Iterator&lt;WorkerThread&gt; workerThreads = createWorkerThreads(count).iterator();</div><div>    while(workerThreads.hasNext()) {</div><div>        WorkerThread wt = workerThreads.next();</div><div>        <b>wt.start();</b></div><div>        availWorkers.add(wt);</div><div>    }</div><div>}</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//生成</span>createCount数量的工作线程，并将其加入workers队列</div><div>protected List&lt;WorkerThread&gt; createWorkerThreads(int createCount) {</div><div>    workers = new LinkedList&lt;WorkerThread&gt;();</div><div>    for (int i = 1; i&lt;= createCount; ++i) {</div><div>        //线程名称</div><div>        String threadPrefix = getThreadNamePrefix();</div><div>        if (threadPrefix == null) {</div><div>            threadPrefix = schedulerInstanceName + &quot;_Worker&quot;;</div><div>        }</div><div>        WorkerThread wt = new WorkerThread(this, threadGroup,</div><div>            threadPrefix + &quot;-&quot; + i,</div><div>            getThreadPriority(),</div><div>            isMakeThreadsDaemons());</div><div>        //线程上线文加载器</div><div>        if (isThreadsInheritContextClassLoaderOfInitializingThread()) {</div><div>            wt.setContextClassLoader(Thread.currentThread()</div><div>                    .getContextClassLoader());</div><div>        }</div><div>        workers.add(wt);</div><div>    }</div><div>    return workers;</div><div>}</div></div><div><br/></div><div>3、availWorkers和busyWorkers的作用</div><div>    从名字来看，availWorkers叫可用队列，应该是空闲的工作线程队列，而busyWorkers忙队列，应该是正在执行中的线程工作队列。那整个执行过程应该是现在availWorkers中初始化，干活时将该线程移到busyWorkers队列，干完活再重新放回availWorkers队列，周而复始。先按这个假设去找相应的代码，确认是这个假设正确与否</div><ul><li><div>    初始化：上面一节已经提到，工作线程启动时会被放到availWorkers,但是这步操作是在初始化中进行的，工作线程的执行体还是空的。</div></li><li><div>    干活：第一节第八段中，调用了SimpleThreadPoeol的runInThread方法（已标亮），把工作线程从availWorkers中删除，然后加入busyWorkers队列</div></li><li><div>    干完活归还线程：WorkerThread的run中最后有个finalize,其中将线程从busyWorkers队列删除，放入availWorkers中。具体代码见下</div></li></ul><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void run() {</div><div>    boolean ran = false;</div><div>    </div><div>    while (run.get()) {</div><div>        try {</div><div>            synchronized(lock) {</div><div>                //没活干就一直等待，没半秒钟醒一下看看有活干了吗</div><div>                while (runnable == null &amp;&amp; run.get()) {</div><div>                    lock.wait(500);</div><div>                }</div><div>                if (runnable != null) {</div><div>                    ran = true;</div><div>                    //有活干了就干活</div><div>                    runnable.run();</div><div>                }</div><div>            }</div><div>        } catch (InterruptedException unblock) {</div><div>            // do nothing (loop will terminate if shutdown() was called</div><div>            try {</div><div>                getLog().error(&quot;Worker thread was interrupt()'ed.&quot;, unblock);</div><div>            } catch(Exception e) {</div><div>                // ignore to help with a tomcat glitch</div><div>            }</div><div>        } catch (Throwable exceptionInRunnable) {</div><div>            try {</div><div>                getLog().error(&quot;Error while executing the Runnable: &quot;,</div><div>                    exceptionInRunnable);</div><div>            } catch(Exception e) {</div><div>                // ignore to help with a tomcat glitch</div><div>            }</div><div>        } finally {</div><div>            //活儿干完了，就把活儿扔了</div><div>            synchronized(lock) {</div><div>                runnable = null;</div><div>            }</div><div>            // repair the thread in case the runnable mucked it up...</div><div>            if(getPriority() != tp.getThreadPriority()) {</div><div>                setPriority(tp.getThreadPriority());</div><div>            }</div><div>            if (runOnce) {</div><div>                   run.set(false);</div><div>                clearFromBusyWorkersList(this);</div><div>            } else if(ran) {</div><div>                ran = false;</div><div>                //程从busyWorkers队列删除，放入availWorkers中为下次接活做准备</div><div>                makeAvailable(this);</div><div>            }</div><div>        }</div><div>    }</div><div>    //if (log.isDebugEnabled())</div><div>    try {</div><div>        getLog().debug(&quot;WorkerThread is shut down.&quot;);</div><div>    } catch(Exception e) {</div><div>        // ignore to help with a tomcat glitch</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>//程从busyWorkers队列删除，放入availWorkers中</div><div>protected void makeAvailable(WorkerThread wt) {</div><div>    synchronized(nextRunnableLock) {</div><div>        if(!isShutdown) {</div><div>            availWorkers.add(wt);</div><div>        }</div><div>        busyWorkers.remove(wt);</div><div>        nextRunnableLock.notifyAll();</div><div>    }</div><div>}</div></div><div>4、ConcurrentExectionDisallowed的处理</div><div> 要实现不允许并发执行（串行）的效果，只要等到前一个执行完再执行后一个就可以了。</div><div> 最后Job的执行，是被包装秤JobRunShell执行的，在它的执行方法最后，有一行</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>notifyJobStoreJobComplete(trigger, jobDetail, instCode);</div><div><br/></div><div>protected void notifyJobStoreJobComplete(OperableTrigger trigger, JobDetail detail, CompletedExecutionInstruction instCode) {</div><div>    resources.getJobStore().triggeredJobComplete(trigger, detail, instCode);</div><div>}</div><div><br/></div><div>public void triggeredJobComplete(OperableTrigger trigger,</div><div>        JobDetail jobDetail, CompletedExecutionInstruction triggerInstCode) {</div><div>        ……………………</div><div>        if (jd.isConcurrentExectionDisallowed()) {</div><div>            blockedJobs.remove(jd.getKey());</div><div>            ArrayList&lt;TriggerWrapper&gt; trigs = getTriggerWrappersForJob(jd.getKey());</div><div>            for(TriggerWrapper ttw : trigs) {</div><div>                if (ttw.state == TriggerWrapper.STATE_BLOCKED) {</div><div>                    ttw.state = TriggerWrapper.STATE_WAITING;</div><div>                    timeTriggers.add(ttw);</div><div>            }</div><div>            if (ttw.state == TriggerWrapper.STATE_PAUSED_BLOCKED) {</div><div>                ttw.state = TriggerWrapper.STATE_PAUSED;</div><div>            }</div><div>        }</div><div>        signaler.signalSchedulingChange(0L);</div><div>        }</div><div>        ……………………</div><div>}</div></div></div><div><br/></div><div><br/></div><div>补充：1、misfire,错过执行，</div><div>quartz中： <span style="font-size: 14px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; color: rgb(51, 51, 51); font-family: Verdana, Arial, Helvetica, sans-serif; font-variant-caps: normal; font-variant-ligatures: normal;">到了该触发执行时上一个执行还未完成，且线程池中没有空闲线程可以使用（或有空闲线程可以使用但job设置为@DisallowConcurrentExecution）且过期时间已经超过misfireThreshold就认为是misfire了，错失触发</span></div><ol><li><div>时间还在错过执行时间阈值内misfireThreshold（默认值是1ms,在createScheduler方法中指定）</div></li><li><div>misfire的策略,具体可参照： <a href="https://blog.csdn.net/u010648555/article/details/53672738">https://blog.csdn.net/u010648555/article/details/53672738</a></div></li></ol><div>如，作业每5秒执行一次，而作业每次执行耗时6秒，第二轮作业的执行要在第一轮作业执行完毕之后才能执行，也就是在第6秒的时候才能执行，如果misfireThreshold设置为1秒,第二次可在第6秒的时候执行，第二次执行完的时候时间到达了12秒，而第三轮正常应执行时间为第10秒，12-10&gt;1，已经超过了错误时间阈值，本轮作业将跳过，等待下一轮时执行（第15秒）</div><div>        以上结论，通过修改misfireThreshold阈值进行测试（如果是quartz作业，提供一个quartz.properties文件，这个文件quartz的jar包中有，默认值是60000；如果是elasticjob作业，本人是直接在源码中更改的JobScheduler.getBaseQuartzProperties方法中），已验证。</div><div>        </div></div><div>    2、各自责任</div><div>        QuartzSchedulerThread负责调度时间计算，生成JobRunShell作业运行实体，并将其塞入SimpleThreadPool中</div><div>        SimpleThreadPool维护WorkerThread队列，取出空闲的WorkerThread将JobRunShell塞入其中工作</div><div>        WorkerThread运行JobRunShell实例</div><div>    3、关于DisallowConcurrentExecution</div><div>        这个注解是quartz提供的，它负责提供实现这个注解相关的功能，quartz代码是判断job类上面有无这个注解，所以作业类必须是实现job接口的类才会有效，而elastic-job的作业类是实现自elasticJob接口的类，和quartz的Job接口没有直接的继承实现关系，所以elastic-job的作业不支持这个注解。补充一下：quartz最终执行的是job接口的execute函数，但是elasticjob的作业并没有实现这个接口，那它是怎么实现的呢？elastic-job提供了一个LiteJob类实现了Job接口，通过LiteJob的excute函数实现调用elasticjob自己的作业</div></span>
</div></body></html> 