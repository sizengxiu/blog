<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="482"/>

<div>
<span><div>作业的执行是从JobRunShell.run方法开始的。</div><div>run方法执行了job.execute(jec);作业分片过程前文已述，不再赘述</div><div>elastic-job调度主要在AbstractElasticJobExecutor类中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Lite调度作业.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>public final class LiteJob implements Job {</div><div>    </div><div>    @Setter</div><div>    private ElasticJob elasticJob;</div><div>    </div><div>    @Setter</div><div>    private JobFacade jobFacade;</div><div>    </div><div>    @Override</div><div>    public void execute(final JobExecutionContext context) throws JobExecutionException {</div><div>        JobExecutorFactory.getJobExecutor(elasticJob, jobFacade).execute();</div><div>    }</div><div>}</div></div><div>Job是quartz提供的接口</div><div>作业执行器工厂中就只有一个方法：根据作业类型获取获取作业执行器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 作业执行器工厂.</div><div>*</div><div>* @author zhangliang</div><div>*/</div><div>@NoArgsConstructor(access = AccessLevel.PRIVATE)</div><div>public final class JobExecutorFactory {</div><div>    </div><div>    /**</div><div>     * 获取作业执行器.</div><div>     *</div><div>     * @param elasticJob 分布式弹性作业</div><div>     * @param jobFacade 作业内部服务门面服务</div><div>     * @return 作业执行器</div><div>     */</div><div>    @SuppressWarnings(&quot;unchecked&quot;)</div><div>    public static AbstractElasticJobExecutor getJobExecutor(final ElasticJob elasticJob, final JobFacade jobFacade) {</div><div>        if (null == elasticJob) {</div><div>            return new ScriptJobExecutor(jobFacade);</div><div>        }</div><div>        if (elasticJob instanceof SimpleJob) {</div><div>            return new SimpleJobExecutor((SimpleJob) elasticJob, jobFacade);</div><div>        }</div><div>        if (elasticJob instanceof DataflowJob) {</div><div>            return new DataflowJobExecutor((DataflowJob) elasticJob, jobFacade);</div><div>        }</div><div>        throw new JobConfigurationException(&quot;Cannot support job type '%s'&quot;, elasticJob.getClass().getCanonicalName());</div><div>    }</div><div>}</div><div>方法中的是三个作业执行器都继承自AbstractElasticJobExecutor，以SimpleJobExecutor为例</div><div>public SimpleJobExecutor(final SimpleJob simpleJob, final JobFacade jobFacade) {</div><div>    super(jobFacade);</div><div>    this.simpleJob = simpleJob;</div><div>}</div><div>调用了父类的构造方法</div><div>protected AbstractElasticJobExecutor(final JobFacade jobFacade) {</div><div>    this.jobFacade = jobFacade;</div><div>    jobRootConfig = jobFacade.loadJobRootConfiguration(true);</div><div>    jobName = jobRootConfig.getTypeConfig().getCoreConfig().getJobName();</div><div>    executorService = ExecutorServiceHandlerRegistry.getExecutorServiceHandler(jobName, (ExecutorServiceHandler) getHandler(JobProperties.JobPropertiesEnum.EXECUTOR_SERVICE_HANDLER));</div><div>    jobExceptionHandler = (JobExceptionHandler) getHandler(JobProperties.JobPropertiesEnum.JOB_EXCEPTION_HANDLER);</div><div>    itemErrorMessages = new ConcurrentHashMap&lt;&gt;(jobRootConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(), 1);</div><div>}</div><div>/**</div><div>* 获取线程池服务.</div><div>*</div><div>* @param jobName 作业名称</div><div>* @param executorServiceHandler 线程池服务处理器</div><div>* @return 线程池服务</div><div>*/</div><div>public static synchronized ExecutorService getExecutorServiceHandler(final String jobName, final ExecutorServiceHandler executorServiceHandler) {</div><div>    if (!REGISTRY.containsKey(jobName)) {</div><div>        REGISTRY.put(jobName, executorServiceHandler.createExecutorService(jobName));</div><div>    }</div><div>    return REGISTRY.get(jobName);</div><div>}</div><div><br/></div><div>public ExecutorService createExecutorService(final String jobName) {</div><div>    //Runtime.getRuntime().availableProcessors()获取处理器内核数量</div><div>    return new ExecutorServiceObject(&quot;inner-job-&quot; + jobName, Runtime.getRuntime().availableProcessors() * 2).createExecutorService();</div><div>}</div><div>public ExecutorServiceObject(final String namingPattern, final int threadSize) {</div><div>    workQueue = new LinkedBlockingQueue&lt;&gt;();</div><div>    threadPoolExecutor = new ThreadPoolExecutor(threadSize, threadSize, 5L, TimeUnit.MINUTES, workQueue,</div><div>            new BasicThreadFactory.Builder().namingPattern(Joiner.on(&quot;-&quot;).join(namingPattern, &quot;%s&quot;)).build());</div><div>    threadPoolExecutor.allowCoreThreadTimeOut(true);</div><div>}</div></div><div>execute()方法实际执行的是父类的方法</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 执行作业.</div><div>*/</div><div>public final void execute() {</div><div>    try {</div><div>        jobFacade.checkJobExecutionEnvironment();</div><div>    } catch (final JobExecutionEnvironmentException cause) {</div><div>        jobExceptionHandler.handleException(jobName, cause);</div><div>    }</div><div>    //获取分片信息</div><div>    ShardingContexts shardingContexts = jobFacade.getShardingContexts();</div><div>    //发布作业状态追踪事件.</div><div>    if (shardingContexts.isAllowSendJobEvent()) {</div><div>        jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_STAGING, String.format(&quot;Job '%s' execute begin.&quot;, jobName));</div><div>    }</div><div>    //正在执行的作业，标记为错过执行</div><div>    if (jobFacade.misfireIfRunning(shardingContexts.getShardingItemParameters().keySet())) {</div><div>        if (shardingContexts.isAllowSendJobEvent()) {</div><div>            jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(</div><div>                    &quot;Previous job '%s' - shardingItems '%s' is still running, misfired job will start after previous job completed.&quot;, jobName,</div><div>                    shardingContexts.getShardingItemParameters().keySet()));</div><div>        }</div><div>        return;</div><div>    }</div><div>    //清除zookeeper中以前的执行成功的标记</div><div>    jobFacade.cleanPreviousExecutionInfo();</div><div>    try {</div><div>        //执行前通知监听器</div><div>        jobFacade.beforeJobExecuted(shardingContexts);</div><div>        //CHECKSTYLE:OFF</div><div>    } catch (final Throwable cause) {</div><div>        //CHECKSTYLE:ON</div><div>        jobExceptionHandler.handleException(jobName, cause);</div><div>    }</div><div>    //执行job实体</div><div>    execute(shardingContexts, JobExecutionEvent.ExecutionSource.NORMAL_TRIGGER);</div><div>    //执行前面标记为错过执行的分片并清除</div><div>    while (jobFacade.isExecuteMisfired(shardingContexts.getShardingItemParameters().keySet())) {</div><div>        jobFacade.clearMisfire(shardingContexts.getShardingItemParameters().keySet());</div><div>        execute(shardingContexts, JobExecutionEvent.ExecutionSource.MISFIRE);</div><div>    }</div><div>    //任务失败转移</div><div>    jobFacade.failoverIfNecessary();</div><div>    try {</div><div>        //执行后通知监听器</div><div>        jobFacade.afterJobExecuted(shardingContexts);</div><div>        //CHECKSTYLE:OFF</div><div>    } catch (final Throwable cause) {</div><div>        //CHECKSTYLE:ON</div><div>        jobExceptionHandler.handleException(jobName, cause);</div><div>    }</div><div>}</div></div><div>实际执行分片计算的是在JobFacade.getShardingContexts()</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public ShardingContexts getShardingContexts() {</div><div>    boolean isFailover = configService.load(true).isFailover();</div><div>    if (isFailover) {</div><div>        List&lt;Integer&gt; failoverShardingItems = failoverService.getLocalFailoverItems();</div><div>        if (!failoverShardingItems.isEmpty()) {</div><div>            return executionContextService.getJobShardingContext(failoverShardingItems);</div><div>        }</div><div>    }</div><div>    //分片计算，不再细看</div><div>    shardingService.shardingIfNecessary();</div><div>    //获取本地实例分片</div><div>    List&lt;Integer&gt; shardingItems = shardingService.getLocalShardingItems();</div><div>    if (isFailover) {</div><div>        shardingItems.removeAll(failoverService.getLocalHostTakeOffItems());</div><div>    }</div><div>    shardingItems.removeAll(executionService.getDisabledItems(shardingItems));</div><div>    return executionContextService.getJobShardingContext(shardingItems);</div><div>}</div></div><div>从分片之后获取将要在本实例运行的分片</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 获取运行在本作业实例的分片项集合.</div><div>*</div><div>* @return 运行在本作业实例的分片项集合</div><div>*/</div><div>public List&lt;Integer&gt; getLocalShardingItems() {</div><div>    if (JobRegistry.getInstance().isShutdown(jobName) || !serverService.isAvailableServer(JobRegistry.getInstance().getJobInstance(jobName).getIp())) {</div><div>        return Collections.emptyList();</div><div>    }</div><div>    List&lt;Integer&gt; result = new LinkedList&lt;&gt;();</div><div>    int shardingTotalCount = configService.load(true).getTypeConfig().getCoreConfig().getShardingTotalCount();</div><div>    //从Zookeeper中的sharding/instance节点下寻找和本实例id相同的分片，换句话说就是，就是是将要在本实例运行的分片</div><div>    for (int i = 0; i &lt; shardingTotalCount; i++) {</div><div>        if (JobRegistry.getInstance().getJobInstance(jobName).getJobInstanceId().equals(jobNodeStorage.getJobNodeData(ShardingNode.getInstanceNode(i)))) {</div><div>            result.add(i);</div><div>        }</div><div>    }</div><div>    return result;</div><div>}</div></div><div>去除被禁用的分片</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 获取禁用的任务分片项.</div><div>*</div><div>* @param items 需要获取禁用的任务分片项</div><div>* @return 禁用的任务分片项</div><div>*/</div><div>public List&lt;Integer&gt; getDisabledItems(final List&lt;Integer&gt; items) {</div><div>    List&lt;Integer&gt; result = new ArrayList&lt;&gt;(items.size());</div><div>    for (int each : items) {</div><div>        //sharding/disabled</div><div>        if (jobNodeStorage.isJobNodeExisted(ShardingNode.getDisabledNode(each))) {</div><div>            result.add(each);</div><div>        }</div><div>    }</div><div>    return result;</div><div>}</div></div><div><br/></div><div>获取分片信息</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 获取当前作业服务器分片上下文.</div><div>*</div><div>* @param shardingItems 分片项</div><div>* @return 分片上下文</div><div>*/</div><div>public ShardingContexts getJobShardingContext(final List&lt;Integer&gt; shardingItems) {</div><div>    LiteJobConfiguration liteJobConfig = configService.load(false);</div><div>    removeRunningIfMonitorExecution(liteJobConfig.isMonitorExecution(), shardingItems);</div><div>    if (shardingItems.isEmpty()) {</div><div>        return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div>                liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), Collections.&lt;Integer, String&gt;emptyMap());</div><div>    }</div><div>    //一逗号为分隔符，将分片参数转化为map</div><div>    Map&lt;Integer, String&gt; shardingItemParameterMap = new ShardingItemParameters(liteJobConfig.getTypeConfig().getCoreConfig().getShardingItemParameters()).getMap();</div><div>    return new ShardingContexts(buildTaskId(liteJobConfig, shardingItems), liteJobConfig.getJobName(), liteJobConfig.getTypeConfig().getCoreConfig().getShardingTotalCount(),</div><div>            liteJobConfig.getTypeConfig().getCoreConfig().getJobParameter(), getAssignedShardingItemParameterMap(shardingItems, shardingItemParameterMap));</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void removeRunningIfMonitorExecution(final boolean monitorExecution, final List&lt;Integer&gt; shardingItems) {</div><div>    if (!monitorExecution) {</div><div>        return;</div><div>    }</div><div>    List&lt;Integer&gt; runningShardingItems = new ArrayList&lt;&gt;(shardingItems.size());</div><div>    for (int each : shardingItems) {</div><div>        //sharding/running节点</div><div>        if (isRunning(each)) {</div><div>            runningShardingItems.add(each);</div><div>        }</div><div>    }</div><div>    shardingItems.removeAll(runningShardingItems);</div><div>}</div></div><div>按分片号分配分片参数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private Map&lt;Integer, String&gt; getAssignedShardingItemParameterMap(final List&lt;Integer&gt; shardingItems, final Map&lt;Integer, String&gt; shardingItemParameterMap) {</div><div>    Map&lt;Integer, String&gt; result = new HashMap&lt;&gt;(shardingItemParameterMap.size(), 1);</div><div>    for (int each : shardingItems) {</div><div>        result.put(each, shardingItemParameterMap.get(each));</div><div>    }</div><div>    return result;</div><div>}</div></div><div>如果作业还在执行中，标记为错过</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 设置任务被错过执行的标记.</div><div>*</div><div>* @param shardingItems 需要设置错过执行的任务分片项</div><div>* @return 是否满足misfire条件</div><div>*/</div><div>public boolean misfireIfRunning(final Collection&lt;Integer&gt; shardingItems) {</div><div>    return executionService.misfireIfRunning(shardingItems);</div><div>}</div><div><br/></div><div>/**</div><div>* 如果当前分片项仍在运行则设置任务被错过执行的标记.</div><div>*</div><div>* @param items 需要设置错过执行的任务分片项</div><div>* @return 是否错过本次执行</div><div>*/</div><div>public boolean misfireIfRunning(final Collection&lt;Integer&gt; items) {</div><div>    if (!hasRunningItems(items)) {</div><div>        return false;</div><div>    }</div><div>    for (int each : items) {</div><div>        //sharding/misfire节点</div><div>        jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getMisfireNode(each));</div><div>    }</div><div>    return true;</div><div>}</div></div><div>清理作业上次运行信息</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* 清理作业上次运行时信息.</div><div>* 只会在主节点进行.</div><div>*/</div><div>public void cleanPreviousExecutionInfo() {</div><div>    if (!configService.load(true).isMonitorExecution()) {</div><div>        return;</div><div>    }</div><div>    //主节点执行</div><div>    if (leaderService.isLeaderUntilBlock()) {</div><div>        //zookeeper上创建临时节点leader/sharding/cleaning,标记正在清理</div><div>        jobNodeStorage.fillEphemeralJobNode(ShardingNode.CLEANING, &quot;&quot;);</div><div>        List&lt;Integer&gt; items = getAllItems();</div><div>        for (int each : items) {</div><div>            //删除上次执行完成的标记:sharding/completed</div><div>            jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getCompletedNode(each));</div><div>        }</div><div>        //清除正在清理标记</div><div>        jobNodeStorage.removeJobNodeIfExisted(ShardingNode.CLEANING);</div><div>    }</div><div>    while (jobNodeStorage.isJobNodeExisted(ShardingNode.CLEANING)) {</div><div>        BlockUtils.waitingShortTime();</div><div>    }</div><div>}</div></div><div>开始执行作业</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void execute(final ShardingContexts shardingContexts, final JobExecutionEvent.ExecutionSource executionSource) {</div><div>    //没有要执行的分片，直接返回   </div><div> if (shardingContexts.getShardingItemParameters().isEmpty()) {</div><div>        if (shardingContexts.isAllowSendJobEvent()) {</div><div>            jobFacade.postJobStatusTraceEvent(shardingContexts.getTaskId(), State.TASK_FINISHED, String.format(&quot;Sharding item for job '%s' is empty.&quot;, jobName));</div><div>        }</div><div>        return;</div><div>    }</div><div>    //注册作业开始执行信息</div><div>    jobFacade.registerJobBegin(shardingContexts);</div><div>    String taskId = shardingContexts.getTaskId();</div><div>    //发布开始执行事件</div><div>    if (shardingContexts.isAllowSendJobEvent()) {</div><div>        jobFacade.postJobStatusTraceEvent(taskId, State.TASK_RUNNING, &quot;&quot;);</div><div>    }</div><div>    try {</div><div>        process(shardingContexts, executionSource);</div><div>    } finally {</div><div>        // TODO 考虑增加作业失败的状态，并且考虑如何处理作业失败的整体回路</div><div>        jobFacade.registerJobCompleted(shardingContexts);</div><div>        if (itemErrorMessages.isEmpty()) {</div><div>            if (shardingContexts.isAllowSendJobEvent()) {</div><div>                //发布作业执行完成事件</div><div>                jobFacade.postJobStatusTraceEvent(taskId, State.TASK_FINISHED, &quot;&quot;);</div><div>            }</div><div>        } else {</div><div>            if (shardingContexts.isAllowSendJobEvent()) {</div><div>                //发布作业执行异常事件</div><div>                jobFacade.postJobStatusTraceEvent(taskId, State.TASK_ERROR, itemErrorMessages.toString());</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div>注册作业启动信息</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void registerJobBegin(final ShardingContexts shardingContexts) {</div><div>    executionService.registerJobBegin(shardingContexts);</div><div>}</div><div><br/></div><div>/**</div><div>* 注册作业启动信息.</div><div>*</div><div>* @param shardingContexts 分片上下文</div><div>*/</div><div>public void registerJobBegin(final ShardingContexts shardingContexts) {</div><div>    //将要执行的job放入注册器的jobRunningMap中</div><div>    JobRegistry.getInstance().setJobRunning(jobName, true);</div><div>    if (!configService.load(true).isMonitorExecution()) {</div><div>        return;</div><div>    }</div><div>    for (int each : shardingContexts.getShardingItemParameters().keySet()) {</div><div>        //添加临时节点sharding/running记录执行信息</div><div>        jobNodeStorage.fillEphemeralJobNode(ShardingNode.getRunningNode(each), &quot;&quot;);</div><div>    }</div><div>}</div><div><br/></div><div>/**</div><div>* 设置作业是否在运行.</div><div>*</div><div>* @param jobName 作业名称</div><div>* @param isRunning 作业是否在运行</div><div>*/</div><div>public void setJobRunning(final String jobName, final boolean isRunning) {</div><div>    jobRunningMap.put(jobName, isRunning);</div><div>}</div><div><br/></div><div>/**</div><div>* 注册作业完成信息.</div><div>*</div><div>* @param shardingContexts 分片上下文</div><div>*/</div><div>public void registerJobCompleted(final ShardingContexts shardingContexts) {</div><div>    JobRegistry.getInstance().setJobRunning(jobName, false);</div><div>    if (!configService.load(true).isMonitorExecution()) {</div><div>        return;</div><div>    }</div><div>    for (int each : shardingContexts.getShardingItemParameters().keySet()) {</div><div>        ensureShardingItemCompleteAndRemoveRunningStatus(each);</div><div>    }</div><div>}</div><div>//把running改成complete</div><div>private void ensureShardingItemCompleteAndRemoveRunningStatus(final int shardingItem) {</div><div>    jobNodeStorage.createJobNodeIfNeeded(ShardingNode.getCompletedNode(shardingItem));</div><div>    jobNodeStorage.removeJobNodeIfExisted(ShardingNode.getRunningNode(shardingItem));</div><div>}</div></div><div>process</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void process(final ShardingContexts shardingContexts, final JobExecutionEvent.ExecutionSource executionSource) {</div><div>    Collection&lt;Integer&gt; items = shardingContexts.getShardingItemParameters().keySet();</div><div>    //如果只有一个分片任务在本实例执行</div><div>    if (1 == items.size()) {</div><div>        int item = shardingContexts.getShardingItemParameters().keySet().iterator().next();</div><div>        JobExecutionEvent jobExecutionEvent =  new JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, item);</div><div>        process(shardingContexts, item, jobExecutionEvent);</div><div>        return;</div><div>    }</div><div>    //如果多个分片在本实例执行，用线程池执行</div><div>    final CountDownLatch latch = new CountDownLatch(items.size());</div><div>    for (final int each : items) {</div><div>        final JobExecutionEvent jobExecutionEvent = new JobExecutionEvent(shardingContexts.getTaskId(), jobName, executionSource, each);</div><div>        if (executorService.isShutdown()) {</div><div>            return;</div><div>        }</div><div>        executorService.submit(new Runnable() {</div><div>            </div><div>            @Override</div><div>            public void run() {</div><div>                try {</div><div>                    process(shardingContexts, each, jobExecutionEvent);</div><div>                } finally {</div><div>                    //等所有分片作业执行完，外层线程（WorkerThread）才继续执行</div><div>                    latch.countDown();</div><div>                }</div><div>            }</div><div>        });</div><div>    }</div><div>    try {</div><div>        latch.await();</div><div>    } catch (final InterruptedException ex) {</div><div>        Thread.currentThread().interrupt();</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>private void process(final ShardingContexts shardingContexts, final int item, final JobExecutionEvent startEvent) {</div><div>    if (shardingContexts.isAllowSendJobEvent()) {</div><div>        jobFacade.postJobExecutionEvent(startEvent);</div><div>    }</div><div>    log.trace(&quot;Job '{}' executing, item is: '{}'.&quot;, jobName, item);</div><div>    JobExecutionEvent completeEvent;</div><div>    try {</div><div>        process(new ShardingContext(shardingContexts, item));</div><div>        completeEvent = startEvent.executionSuccess();</div><div>        log.trace(&quot;Job '{}' executed, item is: '{}'.&quot;, jobName, item);</div><div>        if (shardingContexts.isAllowSendJobEvent()) {</div><div>            jobFacade.postJobExecutionEvent(completeEvent);</div><div>        }</div><div>        // CHECKSTYLE:OFF</div><div>    } catch (final Throwable cause) {</div><div>        // CHECKSTYLE:ON</div><div>        completeEvent = startEvent.executionFailure(cause);</div><div>        jobFacade.postJobExecutionEvent(completeEvent);</div><div>        itemErrorMessages.put(item, ExceptionUtil.transform(cause));</div><div>        jobExceptionHandler.handleException(jobName, cause);</div><div>    }</div><div>}</div><div>调用子类的process，方法中调用作业的execute方法，也就是我们的作业实现的elasticJob的接口的方法</div><div>protected void process(final ShardingContext shardingContext) {</div><div>    simpleJob.execute(shardingContext);</div><div>}</div></div><div><br/></div><div>补充：</div><div>关于misfire和并发执行，二者会互相响应，再加上quartz和elastic-job均对二者做了管控，耗费大量时间才该清楚二者区别</div><div>1、关于elastic-job的并发执行：</div><div>        前面quartz的线程执行过程中已经说明，DisallowConcurrentExecution注解对elastic-job无效，那为什么还是不能并发执行？比如，作业每3秒执行一次，每次执行耗时5秒，由于允许并发执行，第二次执行时间应该在第3秒，但测试事实是在第6秒（或者第5秒，看是否满足misfire执行条件）运行。但是，如果一个服务实例上存在多个分片，这多个分片任务又可以并发的执行。</div><div>        先说一下同一个服务实例下各分片的并发执行：前篇已经了解到，quartz最终执行的的SimpleThreadPool中的workthread队列中的线程，当多个分片在同一个实例时，这个几个分片任务只占用线程队列中的一个线程，多个分片任务用elastic-job自己的线程池去执行ExecutorServiceHandler，同时使用CountDownLatch控制，workerThread线程一直阻塞，直到所有分片作业线程执行完。</div><div>        不同轮次的并发执行：前文已经了解到，DisallowConcurrentExecution注解对elastic-job无效，那就相当于elastic-job是可以并发执行的，但是它的并发控制不是quartz控制的，而是它自己空的，monitorExecution参数置为true(默认值就是true)，也就意味着不允许并发执行，在JobScheduler.getBaseQuartzProperties方法中将默认的线程数threadCount改为&gt;1（默认值1）,同时将monitorExecution设为false，此时可以验证不同轮次的作业可以并发的执行。</div><div>2、关于elastic-job的misfire</div><div>    仍以上面的例子为例，满足misfire条件，将在第5秒执行（上一轮执行完立即执行）。</div><div>    首先将上面的threadCount改回默认值1，同时放大misfireThreshold，misfire设为true即可看到效果</div><div>    第二轮作业执行时，第一轮作业仍在执行中，分两种情况，第一种有WorkerThread队列中有空闲的线程，直接执行，但是elastic-job执行前会检测zookeeper中个分片的运行状态，如果有作业（以分片为单位）在运行，则在zookeeper中添加作业分片的misfire信息，当前线程直接返回。上一轮的作业（elastic-job自己的线程）执行完后，会检测有没有misfire的作业，有则清除zookeeper中的misfire信息，并仍然用该线程直接执行。第二种有WorkerThread队列中没有空闲的线程，此时必须等上一轮的作业执行完毕才会有空闲线程，也就不会走到elastic-job的misfire逻辑中去，但最终的调度效果两者是一致的。</div><div><br/></div><div>3、elastic-job-lite中可单次触发作业</div><div><span>    其过程是，单次触发是，往zookeeper的的instances/服务实例的结点内容中写入了内容：TRIGGER,elastic-job-lite-core中监听该节点变化，然后通过注册器获取controller，然后调度</span><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>JobRegistry.getInstance().getJobScheduleController(jobName).triggerJob();</div></div><div><br/></div><div><br/></div><div><br/></div></span>
</div></body></html> 