<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="478"/>

<div>
<span><div>ConcurrentHashMap是升级版的hashTable，是线程安全的，但是它的线程安全实现并不对整个对象加锁，所以性能比较高。</div><div>从下方的图可以看出，它和HashMap以及HashTable没有任何直接的继承关系</div><div><img src="ConcurrentHashMap_files/ConcurrentHashMap.png" type="image/png" data-filename="ConcurrentHashMap.png"/></div><div><br clear="none"/></div><div>1、构造函数以及结构</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public ConcurrentHashMap(int initialCapacity) {</div><div>    if (initialCapacity &lt; 0)</div><div>        throw new IllegalArgumentException();</div><div>    int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ?</div><div>               MAXIMUM_CAPACITY :</div><div>                //该方法和hashMap中实现一样</div><div>               tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1));//<span style="color: #9c004c;">此处为什么要扩大1.5倍+1，原因不明（文末补充说明）</span></div><div>    this.sizeCtl = cap;</div><div>}</div></div><div><br clear="none"/></div><div>比hashMap多了一个</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">//第三个参数是预估的并发修改线程数</span></div><div>public ConcurrentHashMap(int initialCapacity,</div><div>                         float loadFactor, int concurrencyLevel) {</div><div>    if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0)</div><div>        throw new IllegalArgumentException();</div><div>    //如果传入的初始容量大小，小于并发数，则初始容量用并发数计算</div><div>    if (initialCapacity &lt; concurrencyLevel)   // Use at least as many bins</div><div>        initialCapacity = concurrencyLevel;   // as estimated threads</div><div>    //同样是比hashMap多进行了一步初始容量放大操作</div><div>    long size = (long)(1.0 + (long)initialCapacity / loadFactor);//<span style="color: #ff0000;">此处为什么要除以loadFactor+1，原因不明</span>（文末补充说明）</div><div>    int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ?</div><div>        MAXIMUM_CAPACITY : tableSizeFor((int)size);</div><div>    this.sizeCtl = cap;</div><div>}</div></div><div><br clear="none"/></div><div><br clear="none"/></div><div>构造函数将计算后的容量大小存在sizeCtl中，这个和HashMap的容量不太一样，看一下jdk的说明</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>-1是在初始化，其他负数的时候，是在扩容；</div><div>0为默认值</div><div>正数为初始化大小</div><div><br clear="none"/></div><div>/**</div><div>* Table initialization and resizing control.  When negative, the</div><div>* table is being initialized or resized: -1 for initialization,</div><div>* else -(1 + the number of active resizing threads).  Otherwise,</div><div>* when table is null, holds the initial table size to use upon</div><div>* creation, or 0 for default. After initialization, holds the</div><div>* next element count value upon which to resize the table.</div><div>*/</div><div>private transient volatile int sizeCtl;</div></div><div><br clear="none"/></div><div>还有unsafe类相关的一些变量值，先贴出来，后续会用到</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>// Unsafe mechanics</div><div>private static final sun.misc.Unsafe U;</div><div>private static final long SIZECTL;</div><div>private static final long TRANSFERINDEX;</div><div>private static final long BASECOUNT;</div><div>private static final long CELLSBUSY;</div><div>private static final long CELLVALUE;</div><div>private static final long ABASE;</div><div>private static final int ASHIFT;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>static {</div><div>    try {</div><div>        U = sun.misc.Unsafe.getUnsafe();</div><div>        Class&lt;?&gt; k = ConcurrentHashMap.class;</div><div>        SIZECTL = U.objectFieldOffset</div><div>            (k.getDeclaredField(&quot;sizeCtl&quot;));</div><div>        TRANSFERINDEX = U.objectFieldOffset</div><div>            (k.getDeclaredField(&quot;transferIndex&quot;));</div><div>        BASECOUNT = U.objectFieldOffset</div><div>            (k.getDeclaredField(&quot;baseCount&quot;));</div><div>        CELLSBUSY = U.objectFieldOffset</div><div>            (k.getDeclaredField(&quot;cellsBusy&quot;));</div><div>        Class&lt;?&gt; ck = CounterCell.class;</div><div>        CELLVALUE = U.objectFieldOffset</div><div>            (ck.getDeclaredField(&quot;value&quot;));</div><div>        Class&lt;?&gt; ak = Node[].class;</div><div>        //获取数据的偏移量（<span style="color: #ff0000;">static方法又怎么能获取到数据的偏移量？</span>）</div><div>        ABASE = U.arrayBaseOffset(ak);</div><div>        //获取数组中每个元素占用的内存大小</div><div>        int scale = U.arrayIndexScale(ak);</div><div>        if ((scale &amp; (scale - 1)) != 0)</div><div>            throw new Error(&quot;data type scale not a power of two&quot;);</div><div>        ASHIFT = 31 - Integer.numberOfLeadingZeros(scale);</div><div>    } catch (Exception e) {</div><div>        throw new Error(e);</div><div>    }</div><div>}</div></div><div><br clear="none"/></div><div>ConcurrentHashMap的几乎所有成员变量都使用了volatile修饰，以保证可见性</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/* ---------------- Fields -------------- */</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* The array of bins. Lazily initialized upon first insertion.</div><div>* Size is always a power of two. Accessed directly by iterators.</div><div>*/</div><div>transient volatile Node&lt;K,V&gt;[] table;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* The next table to use; non-null only while resizing.</div><div>*/</div><div>private transient volatile Node&lt;K,V&gt;[] nextTable;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* Base counter value, used mainly when there is no contention,</div><div>* but also as a fallback during table initialization</div><div>* races. Updated via CAS.</div><div>*/</div><div>private transient volatile long baseCount;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* Table initialization and resizing control.  When negative, the</div><div>* table is being initialized or resized: -1 for initialization,</div><div>* else -(1 + the number of active resizing threads).  Otherwise,</div><div>* when table is null, holds the initial table size to use upon</div><div>* creation, or 0 for default. After initialization, holds the</div><div>* next element count value upon which to resize the table.</div><div>*/</div><div>private transient volatile int sizeCtl;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* The next table index (plus one) to split while resizing.</div><div>*/</div><div>private transient volatile int transferIndex;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* Spinlock (locked via CAS) used when resizing and/or creating CounterCells.</div><div>*/</div><div>private transient volatile int cellsBusy;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* Table of counter cells. When non-null, size is a power of 2.</div><div>*/</div><div>private transient volatile CounterCell[] counterCells;</div><div><br clear="none"/></div><div><br clear="none"/></div><div>// views</div><div>private transient KeySetView&lt;K,V&gt; keySet;</div><div>private transient ValuesView&lt;K,V&gt; values;</div><div>private transient EntrySetView&lt;K,V&gt; entrySet;</div></div><div><br clear="none"/></div><div>两个节点内部类的成员变量同样使用了volatile进行修饰</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</div><div>    final int hash;</div><div>    final K key;</div><div>    volatile V val;</div><div>    volatile Node&lt;K,V&gt; next;</div></div><div>treeNode</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final class TreeNode&lt;K,V&gt; extends Node&lt;K,V&gt; {</div><div>    TreeNode&lt;K,V&gt; parent;  // red-black tree links</div><div>    TreeNode&lt;K,V&gt; left;</div><div>    TreeNode&lt;K,V&gt; right;</div><div>    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</div><div>    boolean red;</div></div><div>treeBin</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;"><br clear="none"/></span></div><div>static final class TreeBin&lt;K,V&gt; extends Node&lt;K,V&gt; {</div><div>    //树的根节点</div><div>    TreeNode&lt;K,V&gt; root;</div><div>    //first节点是转化成树之前的链表的头结点</div><div>    volatile TreeNode&lt;K,V&gt; first;</div><div>    volatile Thread waiter;</div><div>    //锁状态：0无锁</div><div>    volatile int lockState;</div><div>    // values for lockState</div><div>    static final int WRITER = 1; // set while holding write lock</div><div>    static final int WAITER = 2; // set when waiting for write lock</div><div>    static final int READER = 4; // increment value for setting read lock</div><div><br clear="none"/></div><div>/**</div><div>* Creates bin with initial set of nodes headed by b.</div><div>*/</div><div>TreeBin(TreeNode&lt;K,V&gt; b) {</div><div>    super(TREEBIN, null, null, null);</div><div>    this.first = b;</div><div>TreeBin有一个虚拟的根节点，我暂且称之为虚根节点，<span style="font-size: 9pt; color: #333333; font-family: Monaco;">此处截取了构造函数的前两行，从中可以看出TreeBin 是一个虚节点，实际值从root开始</span></div></div><div>扩容时使用的ForwardingNode</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final class ForwardingNode&lt;K,V&gt; extends Node&lt;K,V&gt; {</div><div>    final Node&lt;K,V&gt;[] nextTable;</div><div>    ForwardingNode(Node&lt;K,V&gt;[] tab) {</div><div>        //hash值设为MOVED状态</div><div>        super(MOVED, null, null, null);</div><div>        this.nextTable = tab;</div><div>    }</div></div><div><br clear="none"/></div><div>2、初始化</div><div>初始化的过程发生在第一次往map中存值的时候，这儿直接看初始化过程。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Initializes table, using the size recorded in sizeCtl.</div><div>*/</div><div>private final Node&lt;K,V&gt;[] initTable() {</div><div>    Node&lt;K,V&gt;[] tab; int sc;</div><div>    while ((tab = table) == null || tab.length == 0) {</div><div>        //小于0说明有其他线程正在初始化，让出cpu，等待下次执行进入while重新判断</div><div>        if ((sc = sizeCtl) &lt; 0)</div><div>            Thread.yield(); // lost initialization race; just spin</div><div>        //通过cas将sc置为-1，cas保证这一步操作只有一个线程能成功，从而只会有一个线程去执行下面的初始化操作</div><div>        else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {</div><div>            try {</div><div>                //双重判断防止重复初始化</div><div>                if ((tab = table) == null || tab.length == 0) {</div><div>                    //如果没有给定初始值，则使用默认值16</div><div>                    int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY;</div><div>                    @SuppressWarnings(&quot;unchecked&quot;)</div><div>                    Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div>                    table = tab = nt;</div><div>                    //将sc变为容量的四分之三，相当于*0.75</div><div>                    sc = n - (n &gt;&gt;&gt; 2);</div><div>                }</div><div>            } finally {</div><div>                sizeCtl = sc;</div><div>            }</div><div>            break;</div><div>        }</div><div>    }</div><div>    return tab;</div><div>}</div></div><div><br clear="none"/></div><div>3、数据保存</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V put(K key, V value) {</div><div>    return putVal(key, value, false);</div><div>}</div><div><br clear="none"/></div><div>/** Implementation for put and putIfAbsent */</div><div>final V putVal(K key, V value, boolean onlyIfAbsent) {</div><div><span style="font-size: 9pt; font-family: Monaco;"><span style="color: #333333;">    </span>    <span style="color: #41ad1c;">//key和value都不允许为null,否则抛出空指针异常</span></span></div><div>    if (key == null || value == null) throw new NullPointerException();</div><div>    int hash = spread(key.hashCode());</div><div>    int binCount = 0;</div><div>    for (Node&lt;K,V&gt;[] tab = table;;) {</div><div>        Node&lt;K,V&gt; f; int n, i, fh;</div><div>        //为空则初始化，</div><div>        if (tab == null || (n = tab.length) == 0)</div><div>            tab = initTable();</div><div>        //cas判断该桶内是否为空</div><div>        else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) {</div><div>            //通过cas存数据，如果存入成功，则跳出循环，否则，说明有其他线程已经在该位置存了数据，重新进入循环</div><div>            if (casTabAt(tab, i, null,</div><div>                         new Node&lt;K,V&gt;(hash, key, value, null)))</div><div>                break;                   // no lock when adding to empty bin</div><div>        }</div><div>        else if ((fh = f.hash) == MOVED)</div><div>            tab = helpTransfer(tab, f);</div><div>        else {</div><div>            V oldVal = null;</div><div>            synchronized (f) {</div><div>                //锁内判断桶的头结点有没有变化，没有变化的话继续操作，否则释放锁进入下一轮循环</div><div>                //这个判断的原因：可能存在其他线程删除或修改了桶的头结点</div><div>                if (tabAt(tab, i) == f) {</div><div>                    //fh为桶头结点的hash值，为负数时表示有其他线程正在变更该桶</div><div>                    if (fh &gt;= 0) {</div><div>                        binCount = 1;//每遍历一个节点，binCount加1，记录桶链表的节点个数，后续用于判断是否需要转换成树</div><div>                        for (Node&lt;K,V&gt; e = f;; ++binCount) {</div><div>                            K ek;</div><div>                            //以下条件满足其中一个说明key已经存在：1、hash值相等且key值完全相等2、key的equals方法相等</div><div>                            //更新value，然后跳出循环</div><div>                            if (e.hash == hash &amp;&amp;</div><div>                                ((ek = e.key) == key ||</div><div>                                 (ek != null &amp;&amp; key.equals(ek)))) {</div><div>                                oldVal = e.val;</div><div>                                if (!onlyIfAbsent)</div><div>                                    e.val = value;</div><div>                                break;</div><div>                            }</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">                                                    //key不存在，则进入下次循环，直到找到该桶链表的尾结点，然后接将新的结点挂在该桶链表的最后位置</span></div><div>                            Node&lt;K,V&gt; pred = e;</div><div>                            if ((e = e.next) == null) {</div><div>                                pred.next = new Node&lt;K,V&gt;(hash, key,</div><div>                                                          value, null);</div><div>                                break;</div><div>                            }</div><div>                        }</div><div>                    }</div><div>                    //如果桶的头结点是树节点，转到树的处理方式</div><div>                    else if (f instanceof TreeBin) {</div><div>                        Node&lt;K,V&gt; p;</div><div>                        binCount = 2;</div><div>                        if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</div><div>                                                       value)) != null) {</div><div>                            oldVal = p.val;</div><div>                            if (!onlyIfAbsent)</div><div>                                p.val = value;</div><div>                        }</div><div>                    }</div><div>                }</div><div>            }</div><div>            if (binCount != 0) {</div><div>                //节点个数大于等于树化阈值（8），转化成树</div><div>                if (binCount &gt;= TREEIFY_THRESHOLD)</div><div>                    treeifyBin(tab, i);</div><div>                if (oldVal != null)//如果是修改，返回旧值</div><div>                    return oldVal;</div><div>                break;</div><div>            }</div><div>        }</div><div>    }</div><div>    addCount(1L, binCount);</div><div>    return null;</div><div>}</div></div><div>获取元素调用tabAt方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final &lt;K,V&gt; Node&lt;K,V&gt; tabAt(Node&lt;K,V&gt;[] tab, int i) {</div><div>    return (Node&lt;K,V&gt;)U.getObjectVolatile(tab, ((long)i &lt;&lt; ASHIFT) + ABASE);</div><div>}</div><div>其中((long)i &lt;&lt; ASHIFT) + ABASE是计算地址偏移量</div></div><div>通过CAS存数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final &lt;K,V&gt; boolean casTabAt(Node&lt;K,V&gt;[] tab, int i, Node&lt;K,V&gt; c, Node&lt;K,V&gt; v) {</div><div>    return U.compareAndSwapObject(tab, ((long)i &lt;&lt; ASHIFT) + ABASE, c, v);</div><div>}</div></div><div>结点hash值含义：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final int MOVED     = -1; // hash for forwarding nodes</div><div>static final int TREEBIN   = -2; // hash for roots of trees</div><div>static final int RESERVED  = -3; // hash for transient reservations</div></div><div><br clear="none"/></div><div>如果桶内节点是树，则走下面这段逻辑</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final TreeNode&lt;K,V&gt; putTreeVal(int h, K k, V v) {</div><div>    Class&lt;?&gt; kc = null;</div><div>    boolean searched = false;</div><div>    for (TreeNode&lt;K,V&gt; p = root;;) {</div><div>        int dir, ph; K pk;</div><div>        if (p == null) {</div><div>            first = root = new TreeNode&lt;K,V&gt;(h, k, v, null, null);</div><div>            break;</div><div>        }</div><div>        else if ((ph = p.hash) &gt; h)</div><div>            dir = -1;</div><div>        else if (ph &lt; h)</div><div>            dir = 1;</div><div>        //经历了前面两个if,此时hash一定相等，如果key相等或者equal相等，则直接返回该节点</div><div>        else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</div><div>            return p;</div><div>        //如果没有比较器，或者比较器不相同，或者值比较不相等</div><div>        else if ((kc == null &amp;&amp;</div><div>                  (kc = comparableClassFor(k)) == null) ||</div><div>                 (dir = compareComparables(kc, k, pk)) == 0) {</div><div>            if (!searched) {</div><div>                TreeNode&lt;K,V&gt; q, ch;</div><div>                searched = true;</div><div>                //从左右子树查找是否存在key相同的结点，如果存在直接返回；否则代码继续往下走</div><div>                if (((ch = p.left) != null &amp;&amp;</div><div>                     (q = ch.findTreeNode(h, k, kc)) != null) ||</div><div>                    ((ch = p.right) != null &amp;&amp;</div><div>                     (q = ch.findTreeNode(h, k, kc)) != null))</div><div>                    return q;</div><div>            }</div><div>            dir = tieBreakOrder(k, pk);</div><div>        }</div><div><br clear="none"/></div><div><br clear="none"/></div><div>        TreeNode&lt;K,V&gt; xp = p;</div><div>        //小于等于时都从左子树</div><div>        if ((p = (dir &lt;= 0) ? p.left : p.right) == null) {</div><div>            TreeNode&lt;K,V&gt; x, f = first;</div><div>            first = x = new TreeNode&lt;K,V&gt;(h, k, v, f, xp);</div><div>            //头结点的前驱指针指向新节点</div><div>            if (f != null)</div><div>                f.prev = x;</div><div>            //根据dir不同，挂在左或右子树上</div><div>            if (dir &lt;= 0)</div><div>                xp.left = x;</div><div>            else</div><div>                xp.right = x;</div><div>            if (!xp.red)</div><div>                x.red = true;</div><div>            else {</div><div>                //在putTreeVal方法前，已经通过synchronized锁住桶头结点，也就是树根节点，此处锁整棵树，是因为红黑树自平衡调整有可能会使得根节点发生变化</div><div>                lockRoot();</div><div>                try {</div><div>                    //这个里面代码只是对插入节点后的红黑树平衡调整</div><div>                    root = balanceInsertion(root, x);</div><div>                } finally {</div><div>                    unlockRoot();</div><div>                }</div><div>            }</div><div>            break;</div><div>        }</div><div>    }</div><div>    assert checkInvariants(root);</div><div>    return null;</div><div>}</div></div><div><br clear="none"/></div><div>获取比较器</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static Class&lt;?&gt; comparableClassFor(Object x) {</div><div>    if (x instanceof Comparable) {</div><div>        Class&lt;?&gt; c; Type[] ts, as; Type t; ParameterizedType p;</div><div>        if ((c = x.getClass()) == String.class) // bypass checks</div><div>            return c;</div><div>        if ((ts = c.getGenericInterfaces()) != null) {//获取接口</div><div>            for (int i = 0; i &lt; ts.length; ++i) {</div><div>                if (((t = ts[i]) instanceof ParameterizedType) &amp;&amp;</div><div>                    ((p = (ParameterizedType)t).getRawType() ==</div><div>                     Comparable.class) &amp;&amp;</div><div>                    (as = p.getActualTypeArguments()) != null &amp;&amp;</div><div>                    as.length == 1 &amp;&amp; as[0] == c) // type arg is c</div><div>                    return c;</div><div>            }</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div><br clear="none"/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">x为空或者不是同一个比较器，则返回0，否则返回比较大小</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static int compareComparables(Class&lt;?&gt; kc, Object k, Object x) {</div><div>    return (x == null || x.getClass() != kc ? 0 :</div><div>            ((Comparable)k).compareTo(x));</div><div>}</div></div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final TreeNode&lt;K,V&gt; findTreeNode(int h, Object k, Class&lt;?&gt; kc) {</div><div>    if (k != null) {</div><div>        TreeNode&lt;K,V&gt; p = this;</div><div>        do  {</div><div>            int ph, dir; K pk; TreeNode&lt;K,V&gt; q;</div><div>            TreeNode&lt;K,V&gt; pl = p.left, pr = p.right;</div><div>            //hash值小，从左子树找</div><div>            if ((ph = p.hash) &gt; h)</div><div>                p = pl;</div><div>            //hash值大，从右子树找</div><div>            else if (ph &lt; h)</div><div>                p = pr;</div><div>            //hash相等，key相同 直接返回</div><div>            else if ((pk = p.key) == k || (pk != null &amp;&amp; k.equals(pk)))</div><div>                return p;</div><div>            //hash相等，左子树为空，从右子树找</div><div>            else if (pl == null)</div><div>                p = pr;</div><div>            //hash相等，左子树不为空，右子树为空，从左子树找</div><div>            else if (pr == null)</div><div>                p = pl;</div><div>            //hash相等，左右字数均不为空，且存在比较器</div><div>            else if ((kc != null ||</div><div>                      (kc = comparableClassFor(k)) != null) &amp;&amp;</div><div>                     (dir = compareComparables(kc, k, pk)) != 0)</div><div>                //小于节点key,从左子树找，大于，从右子树找</div><div>                p = (dir &lt; 0) ? pl : pr;</div><div>            //递归</div><div>            else if ((q = pr.findTreeNode(h, k, kc)) != null)</div><div>                return q;</div><div>            else</div><div>                p = pl;</div><div>        } while (p != null);//未找到key相同的，截止，返回null</div><div>    }</div><div>    return null;</div><div>}</div></div><div>putTreeVal接下来用到了tieBreakOrder方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Tie-breaking utility for ordering insertions when equal</div><div>* hashCodes and non-comparable. We don't require a total</div><div>* order, just a consistent insertion rule to maintain</div><div>* equivalence across rebalancings. Tie-breaking further than</div><div>* necessary simplifies testing a bit.</div><div>*/</div><div>static int tieBreakOrder(Object a, Object b) {</div><div>    int d;</div><div>    if (a == null || b == null ||</div><div>        (d = a.getClass().getName().</div><div>         compareTo(b.getClass().getName())) == 0)</div><div>        d = (System.identityHashCode(a) &lt;= System.identityHashCode(b) ?</div><div>             -1 : 1);</div><div>    return d;</div><div>}</div><div><br clear="none"/></div><div>在调用该方法前已可以确定a、b（就是key）均不会为null,但是是不是同一个类就不一定了</div><div>    不是同一个类时，返回0</div><div>    是同一个类时，返回原生hashCode大小比较，注意相等时，返回-1；</div><div>关于System.identityHashCode  下方有说明</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">方法注释上说，在hash值相等且</span>non-comparable情况下使用该方法，non-comparable我一开始以为是没有比较器的意思，但是发现，当存在比较器，且二者比较大小相同的情况下，也会进入该方法，所以也不知道该怎么表达这个词的含义</div></div><div><br clear="none"/></div><div>看一下锁树的过程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private final void lockRoot() {</div><div>    if (!U.compareAndSwapInt(this, LOCKSTATE, 0, WRITER))</div><div>        contendedLock(); // offload to separate method</div><div>}</div><div>cas改变树的锁状态为writer（1）状态</div><div>cas成功直接返回，否则进入contendedLock</div><div><span style="color: #41ad1c;">什么情况下会cas失败？一开始时以为一个线程正在调整树，根节点发生变化，此时锁状态为writer(1),另一个线程又落入了相同桶,状态不为0，cas失败；后来发现，红黑树的自平衡调整，压根就不会改变虚根节点（地址不变，里面的真正的根节点可能会变）</span></div><div><br clear="none"/></div><div><br clear="none"/></div><div><br clear="none"/></div><div>/**</div><div>* Possibly blocks awaiting root lock.</div><div>*/</div><div>private final void contendedLock() {</div><div>    boolean waiting = false;</div><div>    for (int s;;) {</div><div>        //TreeBin中锁状态总共提供有四个值：0、1、2、4，对应二进制位000、001、010、100（只写了后三位）</div><div>        //这个方法继续往下看，就会发现状态并不是四个，还有两个状态3和6，分别对应：011  、 110，这两个状态并不满足第一个if</div><div>        //WAITER为2，~WAITER就是 101，所以当lockState为 0（无锁）和010（等待状态）时，下面if条件成立，换句话说，在没有锁或者锁状态为waiter时，可以改锁状态为写状态</div><div>        if (((s = lockState) &amp; ~WAITER) == 0) {</div><div>            if (U.compareAndSwapInt(this, LOCKSTATE, s, WRITER)) {</div><div>                if (waiting)</div><div>                    waiter = null;</div><div>                return;</div><div>            }</div><div>        }</div><div>        //WAITER为010,除了它本身的另外三个状态和它相与值都为0，又状态0满足上面的if（多线程下，可能上面if时不为0，下面变成0）,所以锁状态为1（writer）和4(reader)时，进入下面if</div><div>        //所以状态1（写锁）会被改成3，状态4（读锁）会被改成6，又出来两个状态;如果状态本身是3或者6.这个条件也不满足</div><div>        else if ((s &amp; WAITER) == 0) {</div><div>            if (U.compareAndSwapInt(this, LOCKSTATE, s, s | WAITER)) {</div><div>                waiting = true;</div><div>                waiter = Thread.currentThread();//将等待线程设为自己</div><div>            }</div><div>        }</div><div>        //状态3或者6时会进入这个分支</div><div>        //先说下状态6，有一个线程先get会加读锁，然后又有一线程put此时会变成状态6，同时继续循环会使得执行put操作的线程进入下面分支，陷入wait状态；</div><div>        else if (waiting)</div><div>            LockSupport.park(this);//阻塞当前线程，LockSupport在ReentrantLock中大量使用，后续再学习该类</div><div>    }</div><div>}</div><div><br clear="none"/></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;"><br clear="none"/></span></div></div><div>对应的解锁树的过程</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private final void unlockRoot() {</div><div>    lockState = 0;</div><div>}</div><div>只是将锁状态设置成了0，即无锁状态；注意并无对waiter线程的unpark操作</div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">搜索了整个类中的代码，只在find函数中对waiter线程进行了unpark操作</span></div><div><span style="font-size: 9pt; color: #333333; font-family: Monaco;">所以，自旋的线程或者新加入的线程会有yige</span></div></div><div><br clear="none"/></div><div>不变性规则检测</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Recursive invariant check</div><div>*/</div><div>static &lt;K,V&gt; boolean checkInvariants(TreeNode&lt;K,V&gt; t) {</div><div>    TreeNode&lt;K,V&gt; tp = t.parent, tl = t.left, tr = t.right,</div><div>        tb = t.prev, tn = (TreeNode&lt;K,V&gt;)t.next;</div><div>    //当前节点的前驱节点的后继节点一定是当前节点</div><div>    if (tb != null &amp;&amp; tb.next != t)</div><div>        return false;</div><div>    //当前节点的后继节点的前驱节点一定是当前节点</div><div>    if (tn != null &amp;&amp; tn.prev != t)</div><div>        return false;</div><div>    //当前节点一定是当前节点的父节点的 左右子孩子之一</div><div>    if (tp != null &amp;&amp; t != tp.left &amp;&amp; t != tp.right)</div><div>        return false;</div><div>    //当前节点的左孩子节点的父节点是当前节点，且当前节点的hash值小于等于左孩子节点的hash值</div><div>    if (tl != null &amp;&amp; (tl.parent != t || tl.hash &gt; t.hash))</div><div>        return false;</div><div>    //右孩子节点情况同上</div><div>    if (tr != null &amp;&amp; (tr.parent != t || tr.hash &lt; t.hash))</div><div>        return false;</div><div>    //父子节点不可同时为红色</div><div>    if (t.red &amp;&amp; tl != null &amp;&amp; tl.red &amp;&amp; tr != null &amp;&amp; tr.red)</div><div>        return false;</div><div>    //递归检测左子树</div><div>    if (tl != null &amp;&amp; !checkInvariants(tl))</div><div>        return false;</div><div>    //递归检测右子树</div><div>    if (tr != null &amp;&amp; !checkInvariants(tr))</div><div>        return false;</div><div>    return true;</div><div>}</div></div><div><br clear="none"/></div><div>桶内节点数量大于8以后转化成红黑树，这段代码是在synchronized代码块之外的</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private final void treeifyBin(Node&lt;K,V&gt;[] tab, int index) {</div><div>    Node&lt;K,V&gt; b; int n, sc;</div><div>    if (tab != null) {</div><div>        if ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)//这个常量值是64</div><div>            tryPresize(n &lt;&lt; 1);</div><div>        //b.hash &gt;= 0说明不是树结构，树的根节点hash=-2</div><div>        else if ((b = tabAt(tab, index)) != null &amp;&amp; b.hash &gt;= 0) {</div><div>            synchronized (b) {</div><div>                if (tabAt(tab, index) == b) {</div><div>                    //这两个变量看了半天，你写个head和tail会死啊！</div><div>                    TreeNode&lt;K,V&gt; hd = null, tl = null;</div><div>                    for (Node&lt;K,V&gt; e = b; e != null; e = e.next) {</div><div>                        TreeNode&lt;K,V&gt; p =</div><div>                            new TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</div><div>                                              null, null);</div><div>                        if ((p.prev = tl) == null)</div><div>                            hd = p;</div><div>                        else</div><div>                            tl.next = p;</div><div>                        tl = p;</div><div>                    }</div><div>                    //在TreeBin构造函数中进行构造一个红黑树</div><div>                    setTabAt(tab, index, new TreeBin&lt;K,V&gt;(hd));</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>}</div><div><br clear="none"/></div><div><br clear="none"/></div><div>private final void tryPresize(int size) {</div><div>    int c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY :</div><div>        tableSizeFor(size + (size &gt;&gt;&gt; 1) + 1);//右见扩大为1.5倍+1，然后tableSize计算大小</div><div>    int sc;</div><div>    while ((sc = sizeCtl) &gt;= 0) {</div><div>        Node&lt;K,V&gt;[] tab = table; int n;</div><div>        //使用putAll也会调用该方法，此时可能会满足下面条件</div><div>        if (tab == null || (n = tab.length) == 0) {</div><div>            n = (sc &gt; c) ? sc : c;</div><div>            //下面代码眼熟不？和initTable何其相似，就是初始化过程</div><div>            if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) {</div><div>                try {</div><div>                    if (table == tab) {</div><div>                        @SuppressWarnings(&quot;unchecked&quot;)</div><div>                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n];</div><div>                        table = nt;</div><div>                        sc = n - (n &gt;&gt;&gt; 2);//0.75倍</div><div>                    }</div><div>                } finally {</div><div>                    sizeCtl = sc;</div><div>                }</div><div>            }</div><div>        }</div><div>        //从putVal调用进来的话，此if不会满足，所以不考虑这种情况</div><div>        else if (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</div><div>            break;</div><div>        else if (tab == table) {</div><div>            int rs = resizeStamp(n);</div><div>            if (sc &lt; 0) {</div><div>                Node&lt;K,V&gt;[] nt;</div><div>                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div>                    transferIndex &lt;= 0)</div><div>                    break;</div><div>                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div>                    transfer(tab, nt);</div><div>            }</div><div>            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div>                transfer(tab, null);</div><div>        }</div><div>    }</div><div>}</div></div><div><br clear="none"/></div><div>transfer</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Moves and/or copies the nodes in each bin to new table. See</div><div>* above for explanation.</div><div>*/</div><div>private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) {</div><div>    int n = tab.length, stride;</div><div>    //其中NCPU为cpu数量</div><div>    if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</div><div>        stride = MIN_TRANSFER_STRIDE; // subdivide range</div><div>    //初始化扩容后的存放数组</div><div>    if (nextTab == null) {            // initiating</div><div>        try {</div><div>            @SuppressWarnings(&quot;unchecked&quot;)</div><div>            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1];</div><div>            nextTab = nt;</div><div>        } catch (Throwable ex) {      // try to cope with OOME</div><div>            sizeCtl = Integer.MAX_VALUE;</div><div>            return;</div><div>        }</div><div>        nextTable = nextTab;</div><div>        transferIndex = n;</div><div>    }</div><div>    int nextn = nextTab.length;</div><div>    //这是个特殊的Node结点，构造函数中将hash值设为MOVED（-1）</div><div>    ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab);</div><div>    boolean advance = true;</div><div>    boolean finishing = false; // to ensure sweep before committing nextTab</div><div>    for (int i = 0, bound = 0;;) {</div><div>        Node&lt;K,V&gt; f; int fh;</div><div>        while (advance) {</div><div>            int nextIndex, nextBound;</div><div>            if (--i &gt;= bound || finishing)</div><div>                advance = false;</div><div>            else if ((nextIndex = transferIndex) &lt;= 0) {</div><div>                i = -1;</div><div>                advance = false;</div><div>            }</div><div>            else if (U.compareAndSwapInt</div><div>                     (this, TRANSFERINDEX, nextIndex,</div><div>                      nextBound = (nextIndex &gt; stride ?</div><div>                                   nextIndex - stride : 0))) {</div><div>                bound = nextBound;</div><div>                //<font color="#328712">i从最后一个位置的桶开始，也就是说，扩容是按桶位置从后往前处理的</font></div><div>                i = nextIndex - 1;</div><div>                advance = false;</div><div>            }</div><div>        }</div><div>        if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) {</div><div>            int sc;</div><div>            if (finishing) {</div><div>                nextTable = null;</div><div>                table = nextTab;</div><div>                sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1);</div><div>                return;</div><div>            }</div><div>            if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) {</div><div>                //<span style="color: #ff4635;">整个循环会循环两遍，具体原因尚未想到（猜测，一遍扩容完了之后，第二次扩容开始，辅助第二次扩容）</span></div><div>                if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</div><div>                    return;</div><div>                finishing = advance = true;</div><div>                i = n; // recheck before commit</div><div>            }</div><div>        }</div><div>        //桶中没有结点，在通知放置一个ForwardingNode节点（MOVED）进入下轮循环</div><div>        else if ((f = tabAt(tab, i)) == null)</div><div>            advance = casTabAt(tab, i, null, fwd);</div><div>        //桶不为空，头节点hash为MOVED表明该桶已经处理过</div><div>        else if ((fh = f.hash) == MOVED)</div><div>            advance = true; // already processed</div><div>        else {</div><div>            //锁住头结点</div><div>            synchronized (f) {</div><div>                //双重判断，防止多个线程处理同一个桶</div><div>                if (tabAt(tab, i) == f) {</div><div>                    Node&lt;K,V&gt; ln, hn;</div><div>                    if (fh &gt;= 0) {</div><div>                        int runBit = fh &amp; n;</div><div>                        Node&lt;K,V&gt; lastRun = f;</div><div>                        //这个for和下面两个if感觉有点多余，直接在下面的for判断是否到达链表末尾不就wna</div><div>                        for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) {</div><div>                            int b = p.hash &amp; n;</div><div>                            if (b != runBit) {</div><div>                                runBit = b;</div><div>                                lastRun = p;</div><div>                            }</div><div>                        }</div><div>                        if (runBit == 0) {</div><div>                            ln = lastRun;</div><div>                            hn = null;</div><div>                        }</div><div>                        else {</div><div>                            hn = lastRun;</div><div>                            ln = null;</div><div>                        }</div><div>                        //同hashMap一样，分高低指针分别指向桶位置变化和不变化的结点</div><div>                        for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) {</div><div>                            int ph = p.hash; K pk = p.key; V pv = p.val;</div><div>                            //存取数据时计算桶的位置是用hash&amp;(n-1),下面判断==0是位置不会变化的几点，=1是会变化的</div><div>                            if ((ph &amp; n) == 0)</div><div>                                ln = new Node&lt;K,V&gt;(ph, pk, pv, ln);</div><div>                            else</div><div>                                hn = new Node&lt;K,V&gt;(ph, pk, pv, hn);</div><div>                        }</div><div>                        //低位指针存在新数组原来位置</div><div>                        setTabAt(nextTab, i, ln);</div><div>                        //高位指针存在新位置</div><div>                        setTabAt(nextTab, i + n, hn);</div><div>                        //将当前桶头结点标记为MOVED</div><div>                        setTabAt(tab, i, fwd);</div><div>                        advance = true;</div><div>                    }</div><div>                    <span style="color: #e30000;">/</span><span style="color: #4dce1d;">/问题来了，为什么上面hash&gt;=0就直接当链表处理？（看完其他代码后补充的答案）TreeBin的Node是个虚节点，hash值是TREEBIN（-2），实际数据从first开始</span></div><div>                    //下面是结点是树的情况和hashMap处理如出一辙</div><div>                    else if (f instanceof TreeBin) {</div><div>                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div>                        TreeNode&lt;K,V&gt; lo = null, loTail = null;</div><div>                        TreeNode&lt;K,V&gt; hi = null, hiTail = null;</div><div>                        int lc = 0, hc = 0;</div><div>                        for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) {</div><div>                            int h = e.hash;</div><div>                            TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt;</div><div>                                (h, e.key, e.val, null, null);</div><div>                            if ((h &amp; n) == 0) {</div><div>                                if ((p.prev = loTail) == null)</div><div>                                    lo = p;</div><div>                                else</div><div>                                    loTail.next = p;</div><div>                                loTail = p;</div><div>                                ++lc;</div><div>                            }</div><div>                            else {</div><div>                                if ((p.prev = hiTail) == null)</div><div>                                    hi = p;</div><div>                                else</div><div>                                    hiTail.next = p;</div><div>                                hiTail = p;</div><div>                                ++hc;</div><div>                            }</div><div>                        }</div><div>                        //大于树化阈值则建树，否则退化为链表</div><div>                        ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</div><div>                            (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t;</div><div>                        hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</div><div>                            (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t;</div><div>                        setTabAt(nextTab, i, ln);</div><div>                        setTabAt(nextTab, i + n, hn);</div><div>                        setTabAt(tab, i, fwd);</div><div>                        advance = true;</div><div>                    }</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>}</div></div><div>元素存完之后调用了addCount()方法，该方法主要用于判断是否需要扩容，如果需要则调用transfer方法进行扩容</div><div><br clear="none"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private final void addCount(long x, int check) {</div><div>    CounterCell[] as; long b, s;</div><div>    //这个if先无视</div><div>    //baseCount为现有元素个数</div><div>    if ((as = counterCells) != null ||</div><div>        !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) {</div><div>        CounterCell a; long v; int m;</div><div>        boolean uncontended = true;</div><div>        if (as == null || (m = as.length - 1) &lt; 0 ||</div><div>            (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null ||</div><div>            !(uncontended =</div><div>              U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) {</div><div>            fullAddCount(x, uncontended);</div><div>            return;</div><div>        }</div><div>        if (check &lt;= 1)</div><div>            return;</div><div>        s = sumCount();</div><div>    }</div><div>    //putVal方法调用时传入的check是&gt;=0的</div><div>    if (check &gt;= 0) {</div><div>        Node&lt;K,V&gt;[] tab, nt; int n, sc;</div><div>        //上面的if条件虽然不能满足，但是会给s赋值为当前元素数量+check数，大于sizeCtl说明需要扩容</div><div>        while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp;</div><div>               (n = tab.length) &lt; MAXIMUM_CAPACITY) {</div><div>            int rs = resizeStamp(n);</div><div>            //sc小于0说明正在初始化或者正在扩容</div><div>            //关于此处理解参考：https://www.cnblogs.com/christmad/p/11385863.html</div><div>            if (sc &lt; 0) {</div><div>                if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div>                    sc == rs + MAX_RESIZERS || (nt = nextTable) == null ||</div><div>                    transferIndex &lt;= 0)</div><div>                    break;</div><div>                //加入扩容阵营，SIZECTL+1</div><div>                if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1))</div><div>                    transfer(tab, nt);</div><div>            }</div><div>            //sc大于0，直接扩容即可，扩容之前修改下SIZECTL的值（负数）</div><div>            else if (U.compareAndSwapInt(this, SIZECTL, sc,</div><div>                                         (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2))</div><div>                transfer(tab, null);</div><div>            s = sumCount();</div><div>        }</div><div>    }</div><div>}</div></div><div><br clear="none"/></div><div>再调过头看另一个==moved的if分支，代码内容就是简化版的addCount()方法，不再赘述</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) {</div><div>    Node&lt;K,V&gt;[] nextTab; int sc;</div><div>    if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp;</div><div>        (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) {</div><div>        int rs = resizeStamp(tab.length);</div><div>        while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</div><div>               (sc = sizeCtl) &lt; 0) {</div><div>            if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 ||</div><div>                sc == rs + MAX_RESIZERS || transferIndex &lt;= 0)</div><div>                break;</div><div>            if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) {</div><div>                transfer(tab, nextTab);</div><div>                break;</div><div>            }</div><div>        }</div><div>        return nextTab;</div><div>    }</div><div>    return table;</div><div>}</div></div><div><br clear="none"/></div><div>4、获取数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V get(Object key) {</div><div>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek;</div><div>    int h = spread(key.hashCode());</div><div>    //桶不为空</div><div>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div>        (e = tabAt(tab, (n - 1) &amp; h)) != null) {</div><div>        if ((eh = e.hash) == h) {</div><div>            //key相等直接返回值</div><div>            if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))</div><div>                return e.val;</div><div>        }</div><div>        //正在初始化、扩容或者是红黑树都会使得hash&lt;0,外层的if排除了正在初始化的可能</div><div>        else if (eh &lt; 0)</div><div>            //无论是红黑树还是正在扩容，这个节点都不会是普通的Node节点，注意<span style="color: #328712;">find方法是多态方法</span>，一开始没注意到这点，看到find方法内部一路next疑惑了好久</div><div>            return (p = e.find(h, key)) != null ? p.val : null;</div><div>        //最后剩下的情况就是链表，一路next判断即可</div><div>        while ((e = e.next) != null) {</div><div>            if (e.hash == h &amp;&amp;</div><div>                ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))))</div><div>                return e.val;</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div>看一下TreeBin的find方法实现</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt; find(int h, Object k) {</div><div>    if (k != null) {</div><div>        for (Node&lt;K,V&gt; e = first; e != null; ) {</div><div>            int s; K ek;</div><div>            //WAITER=10,WRITER=01 ,WAITER|WRITER=11</div><div>            //前面putTreeVal方法中lockRoot时，分析过，lockState会有0,1,2,3,4,6,这几种状态值，只有状态为0、4也就是无锁时不满足下面条件，其他状态都满足if</div><div>            if (((s = lockState) &amp; (WAITER|WRITER)) != 0) {</div><div>                if (e.hash == h &amp;&amp;</div><div>                    ((ek = e.key) == k || (ek != null &amp;&amp; k.equals(ek))))</div><div>                    return e;</div><div>                e = e.next;</div><div>            }</div><div>            //此处lockState=0，苦苦寻觅这个值好久，一致不明白putTreeVal外层已经synchronize头节点了，为什么还要lockRoot,百度好久都没有找到答案，看到此处才恍然大明白，其实分析lockstate值时，看到写、等待、读就应该往读这儿想，只是当时没反应过来</div><div>            //READER=4,s + READER还是4，就是加了读锁</div><div>            else if (U.compareAndSwapInt(this, LOCKSTATE, s,</div><div>                                         s + READER)) {</div><div>                TreeNode&lt;K,V&gt; r, p;</div><div>                try {</div><div>                    //调用treeNode 的findTreeNode方法，具体过程前文已述</div><div>                    p = ((r = root) == null ? null :</div><div>                         r.findTreeNode(h, k, null));</div><div>                } finally {</div><div>                    Thread w;</div><div>                    //此处有个问题迷惑了好久，U.getAndAddInt返回的是增加之前的值，而不是增加之后的值，基础不牢果然是要吃亏的啊！</div><div>                    //READER|WAITER=110=6</div><div>                    //有一个线程先get会加读锁，然后又有一线程put此时会变成状态6，同时执行put操作的线程会陷入wait状态；get线程执行完后如果判断状态=6且waiter线程不为空，就唤醒waiter线程（就是那个put线程），换句话说，如果有多个读线程，要一直等到最后一个读线程执行完，写线程才能得到执行的机会</div><div>                    //<span style="color: #e30000;">问题来了：如果达到状态6之后，来了很多的读线程，状态一直累加，保持在10以上，那写线程岂不是一直得不到执行的机会？</span></div><div>                    if (U.getAndAddInt(this, LOCKSTATE, -READER) ==</div><div>                        (READER|WAITER) &amp;&amp; (w = waiter) != null)</div><div>                        LockSupport.unpark(w);</div><div>                }</div><div>                return p;</div><div>            }</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div>顺便看一眼getAndAddInt方法吧，返回的是add之前的旧值</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public final int getAndAddInt(Object var1, long var2, int var4) {</div><div>    int var5;</div><div>    do {</div><div>        var5 = this.getIntVolatile(var1, var2);</div><div>    } while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4));</div><div><br clear="none"/></div><div><br clear="none"/></div><div>    return var5;</div><div>}</div></div><div><br clear="none"/></div><div>5、删除</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V remove(Object key) {</div><div>    return replaceNode(key, null, null);</div><div>}</div><div><br clear="none"/></div><div>final V replaceNode(Object key, V value, Object cv) {</div><div>    int hash = spread(key.hashCode());</div><div>    for (Node&lt;K,V&gt;[] tab = table;;) {</div><div>        Node&lt;K,V&gt; f; int n, i, fh;</div><div>        //为初始化或者数组长度为0或者桶中没有数据，直接返回</div><div>        if (tab == null || (n = tab.length) == 0 ||</div><div>            (f = tabAt(tab, i = (n - 1) &amp; hash)) == null)</div><div>            break;</div><div>        //如果正在扩容，则一起扩容</div><div>        else if ((fh = f.hash) == MOVED)</div><div>            tab = helpTransfer(tab, f);</div><div>        else {</div><div>            V oldVal = null;</div><div>            boolean validated = false;</div><div>            //又见锁头节点</div><div>            synchronized (f) {</div><div>                //双重判断</div><div>                if (tabAt(tab, i) == f) {</div><div>                    //链表情况</div><div>                    if (fh &gt;= 0) {</div><div>                        validated = true;</div><div>                        for (Node&lt;K,V&gt; e = f, pred = null;;) {</div><div>                            K ek;</div><div>                            if (e.hash == hash &amp;&amp;</div><div>                                ((ek = e.key) == key ||</div><div>                                 (ek != null &amp;&amp; key.equals(ek)))) {</div><div>                                V ev = e.val;</div><div>                                if (cv == null || cv == ev ||</div><div>                                    (ev != null &amp;&amp; cv.equals(ev))) {</div><div>                                    oldVal = ev;</div><div>                                    if (value != null)</div><div>                                        e.val = value;</div><div>                                    //非头节点直接将节点删除</div><div>                                    else if (pred != null)</div><div>                                        pred.next = e.next;</div><div>                                    else</div><div>                                        //如果是头节点，直接让next成为头节点</div><div>                                        setTabAt(tab, i, e.next);</div><div>                                }</div><div>                                break;</div><div>                            }</div><div>                            pred = e;</div><div>                            if ((e = e.next) == null)</div><div>                                break;</div><div>                        }</div><div>                    }</div><div>                    //红黑树情况</div><div>                    else if (f instanceof TreeBin) {</div><div>                        validated = true;</div><div>                        TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</div><div>                        TreeNode&lt;K,V&gt; r, p;</div><div>                        //节点是否存在</div><div>                        if ((r = t.root) != null &amp;&amp;</div><div>                            (p = r.findTreeNode(hash, key, null)) != null) {</div><div>                            V pv = p.val;</div><div>                            if (cv == null || cv == pv ||</div><div>                                (pv != null &amp;&amp; cv.equals(pv))) {</div><div>                                oldVal = pv;</div><div>                                if (value != null)</div><div>                                    p.val = value;</div><div>                                //删除结点，没有详细看内部实现，只关注了它内部调用了lockRoot和unLockRoot方法，说白就是和put方法一样，锁了根节点之后，再用lockState读写锁，逻辑和put方法一模一样不再赘述</div><div>                                else if (t.removeTreeNode(p))</div><div>                                    setTabAt(tab, i, untreeify(t.first));</div><div>                            }</div><div>                        }</div><div>                    }</div><div>                }</div><div>            }</div><div>            if (validated) {</div><div>                if (oldVal != null) {</div><div>                    if (value == null)</div><div>                        addCount(-1L, -1);</div><div>                    return oldVal;</div><div>                }</div><div>                break;</div><div>            }</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div><br clear="none"/></div><div><br/></div><div>6、遍历</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</div><div>    EntrySetView&lt;K,V&gt; es;</div><div>    return (es = entrySet) != null ? es : (entrySet = new <font color="#2D4FC9">EntrySetView</font>&lt;K,V&gt;(this));</div><div>}</div><div>看这个EntrySetView</div><div>static final class EntrySetView&lt;K,V&gt; extends CollectionView&lt;K,V,Map.Entry&lt;K,V&gt;&gt;</div><div>    implements Set&lt;Map.Entry&lt;K,V&gt;&gt;, java.io.Serializable {</div><div>    private static final long serialVersionUID = 2249069246763182397L;</div><div><span>    //构造函数中只是简单传递了map</span><br/></div><div>    EntrySetView(ConcurrentHashMap&lt;K,V&gt; map) { super(map); }</div></div><div>看一下iterator</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</div><div>    ConcurrentHashMap&lt;K,V&gt; m = map;</div><div>    Node&lt;K,V&gt;[] t;</div><div>    int f = (t = m.table) == null ? 0 : t.length;</div><div>    return new EntryIterator&lt;K,V&gt;(t, f, 0, f, m);</div><div>}</div><div>//EntryIterator继承自BaseIterator</div><div>static final class EntryIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt;</div><div>    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    EntryIterator(Node&lt;K,V&gt;[] tab, int index, int size, int limit,</div><div>                  ConcurrentHashMap&lt;K,V&gt; map) {</div><div><span>    </span><span>    //注意与</span>BaseIterator构造函数的参数顺序对比size/index值互换了<br/></div><div>        super(tab, index, size, limit, map);</div><div>    }</div><div>//而BaseIterator又继承自Traverser</div><div>static class BaseIterator&lt;K,V&gt; extends Traverser&lt;K,V&gt; {</div><div>    final ConcurrentHashMap&lt;K,V&gt; map;</div><div>    Node&lt;K,V&gt; lastReturned;</div><div>    BaseIterator(Node&lt;K,V&gt;[] tab, int size, int index, int limit,</div><div>                ConcurrentHashMap&lt;K,V&gt; map) {</div><div>        super(tab, size, index, limit);</div><div>        this.map = map;</div><div><span>    </span><span>    //调用父类这个方法用来初始化next</span><br/></div><div>        advance();</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//信息都记录在</span>Traverser中</div><div>static class Traverser&lt;K,V&gt; {</div><div>    Node&lt;K,V&gt;[] tab;        // current table; updated if resized</div><div>    Node&lt;K,V&gt; next;         // the next entry to use</div><div>    TableStack&lt;K,V&gt; stack, spare; // to save/restore on ForwardingNodes</div><div>    int index;              // index of bin to use next</div><div>    int baseIndex;          // current index of initial table</div><div>    int baseLimit;          // index bound for initial table</div><div>    final int baseSize;     // initial table size</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div></div><div>看一下EntryIterator的next方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public final Map.Entry&lt;K,V&gt; next() {</div><div>    Node&lt;K,V&gt; p;</div><div>    if ((p = next) == null)</div><div>        throw new NoSuchElementException();</div><div>    K k = p.key;</div><div>    V v = p.val;</div><div>    lastReturned = p;</div><div><span>    //寻找下一个next</span><br/></div><div>    advance();</div><div>    return new MapEntry&lt;K,V&gt;(k, v, map);</div><div>}</div></div><div>advance方法是在Tranverse类中</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt; advance() {</div><div>    Node&lt;K,V&gt; e;</div><div>    if ((e = next) != null)</div><div>        e = e.next;</div><div>    for (;;) {</div><div>        Node&lt;K,V&gt;[] t; int i, n;  // must use locals in checks</div><div>        //不为空直接返回</div><div>        if (e != null)</div><div>            return next = e;</div><div>        //遍历完了依然为空</div><div>        if (baseIndex &gt;= baseLimit || (t = tab) == null ||</div><div>            (n = t.length) &lt;= (i = index) || i &lt; 0)</div><div>            return next = null;</div><div>        //正在扩容或者是树的情形会满足if,同时e指向了桶的头结点</div><div>        if ((e = tabAt(t, i)) != null &amp;&amp; e.hash &lt; 0) {</div><div>            //该桶已经处理完毕的情形</div><div>            if (e instanceof ForwardingNode) {</div><div>                tab = ((ForwardingNode&lt;K,V&gt;)e).nextTable;</div><div>                e = null;</div><div>                pushState(t, i, n);</div><div>                continue;</div><div>            }</div><div>            //树</div><div>            else if (e instanceof TreeBin)</div><div>                e = ((TreeBin&lt;K,V&gt;)e).first;</div><div>            else</div><div>                e = null;</div><div>        }</div><div>        if (stack != null)</div><div>            recoverState(n);</div><div>        //下一个桶</div><div>        else if ((index = i + baseSize) &gt;= n)</div><div>            index = ++baseIndex; // visit upper slots if present</div><div>    }</div><div>}</div><div><br/></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//就干了一件事：压栈，扩容前的数组信息记录在tabhe和length中</span></div><div>private void pushState(Node&lt;K,V&gt;[] t, int i, int n) {</div><div>    TableStack&lt;K,V&gt; s = spare;  // reuse if possible</div><div>    if (s != null)</div><div>        spare = s.next;</div><div>    else</div><div>        s = new TableStack&lt;K,V&gt;();</div><div>    s.tab = t;</div><div>    s.length = n;</div><div>    s.index = i;</div><div>    s.next = stack;</div><div>    stack = s;</div><div>}</div><div>//出栈</div><div>private void recoverState(int n) {</div><div>    TableStack&lt;K,V&gt; s; int len;</div><div>    while ((s = stack) != null &amp;&amp; (index += (len = s.length)) &gt;= n) {</div><div>        n = len;</div><div>        index = s.index;</div><div>        tab = s.tab;</div><div>        s.tab = null;</div><div>        TableStack&lt;K,V&gt; next = s.next;</div><div>        s.next = spare; // save for reuse</div><div>        stack = next;</div><div>        spare = s;</div><div>    }</div><div>    if (s == null &amp;&amp; (index += baseSize) &gt;= n)</div><div>        index = ++baseIndex;</div><div>}</div><div><br/></div></div><div>对于扩容情况单独记录一下：</div><div>1、第一次调用next()进入该函数，第一次循环中，遇到ForwardingNode节点，调用pushState，并将e置空，此时tab指向了扩容后的数组，进入第二次循环转2</div><div>2、第二次循环中，拿到额e的值，并且会进入recoverState，此时stack不为空，index变成了index += (len = s.length))就是指向了扩容后的桶中，比如，原数组大小为8，桶index=4扩容后的数据会分布在index=4和index=4+8=12的桶中。此时，e已经有了值，一次next()结束。（这个index直到桶中元素遍历完毕才会发生作用）</div><div>3、第二次调用next()，直接在扩容后的新数组的原桶位置找数据，直接通过节点的next指针找数据，并不会进入循环中，直到next.next==null,即桶中元素遍历完毕，转4</div><div>4、进入循环，由于第二步，此时index指向扩容后的新桶，第二次进入recoverState，index += (len = s.length)) &gt;= n，出栈，tab和重新指向扩容前的数组，然后s==null, index = ++baseIndex;即index指向老数组的下一个桶，本次next()结束，后续next()直接通过节点的next指针找数据直至为空，然后开始在老数组中的index桶中找数据。</div><div><br/></div><div>看一下key和value的遍历</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final class KeyIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt;</div><div>    implements Iterator&lt;K&gt;, Enumeration&lt;K&gt; {</div><div>    KeyIterator(Node&lt;K,V&gt;[] tab, int index, int size, int limit,</div><div>                ConcurrentHashMap&lt;K,V&gt; map) {</div><div>        super(tab, index, size, limit, map);</div><div>    }</div><div><br/></div><div><br/></div><div>    public final K next() {</div><div>        Node&lt;K,V&gt; p;</div><div>        if ((p = next) == null)</div><div>            throw new NoSuchElementException();</div><div>        K k = p.key;</div><div>        lastReturned = p;</div><div>        advance();</div><div>        return k;</div><div>    }</div><div><br/></div><div><br/></div><div>    public final K nextElement() { return next(); }</div><div>}</div><div><br/></div><div><br/></div><div>static final class ValueIterator&lt;K,V&gt; extends BaseIterator&lt;K,V&gt;</div><div>    implements Iterator&lt;V&gt;, Enumeration&lt;V&gt; {</div><div>    ValueIterator(Node&lt;K,V&gt;[] tab, int index, int size, int limit,</div><div>                  ConcurrentHashMap&lt;K,V&gt; map) {</div><div>        super(tab, index, size, limit, map);</div><div>    }</div><div><br/></div><div><br/></div><div>    public final V next() {</div><div>        Node&lt;K,V&gt; p;</div><div>        if ((p = next) == null)</div><div>            throw new NoSuchElementException();</div><div>        V v = p.val;</div><div>        lastReturned = p;</div><div>        advance();</div><div>        return v;</div><div>    }</div><div><br/></div><div><br/></div><div>    public final V nextElement() { return next(); }</div><div>}</div></div><div>同样是利用advance()实现，和HashMap一样，不要使用keyIterator拿到key再去get(key),太二逼了</div><div><br/></div><div><br/></div><div><br/></div><div><br/></div><div>引用其他类的方法：</div><div>    1、System.identityHashCode（以下说明摘自 <a href="https://www.cnblogs.com/godtrue/p/6341473.html" shape="rect">https://www.cnblogs.com/godtrue/p/6341473.html</a>，讲的贼清楚）</div><div>        <span style="font-size: 12px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">  一个对象的hashCode和identityHashCode 的关系：</span></span></div><div style="font-size: 12px; letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">    * 1：对象的hashCode，一般是通过将该对象的内部地址转换成一个整数来实现的</span></div><div style="font-size: 12px; letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">     * 2：当一个类没有重写Object类的hashCode()方法时，它的hashCode和identityHashCode是一致的</span></div><div style="font-size: 12px; letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">     * 3：当一个类重写了Object类的hashCode()方法时，它的hashCode则有重写的实现逻辑决定，此时的hashCode值一般就不再和对象本身的内部地址有相应的哈希关系了</span></div><div style="font-size: 12px; letter-spacing: normal; orphans: 2; white-space: pre-wrap; widows: 2; word-spacing: 0px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">    * 4：当null调用hashCode方法时，会抛出空指针异常，但是调用System.identityHashCode(null)方法时能正常的返回0这个值</span></div><div><span style="font-size: 12px;"><span style="font-size: 12px; font-family: &quot;Courier New&quot;; font-variant-caps: normal; font-variant-ligatures: normal; line-height: 1.5;">     * 5：一个对象的identityHashCode能够始终和该对象的内部地址有一个相对应的关系，从这个角度来讲，它可以用于代表对象的引用地址，所以，在理解==这个操作运算符的时候是比较有用的</span></span></div><div><span style="font-size: 12px;"><span style="font-size: 12px;"><br clear="none"/></span></span></div><div>总结和一些思考：</div><div>    1、<span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">key和value都不允许为null,否则抛出空指针异常</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    2、判断是否相同key,</span><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">以下条件满足其中一个：1、hash值相等且key值完全相等2、key的equals方法相等</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    3、桶中树节点的排序是先按照hash排序，再按照key排序</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    4、当某个桶中节点到达树化阈值后，会将链表转化成树，在转化成树之前会有一个判断，当前数组大小是否达到最小树化容量</span><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">MIN_TREEIFY_CAPACITY，如果没有，则会进行扩容（扩容至原来的两倍）</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    5、根据构造函数中的数组大小计算方式，不传初始化大小，则为默认值16，传了初始化大小为0，则会初始化一个长度为1的数组</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    6、存数据过程总结：</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">            1、第一次存值初始化数组initTable，通过cas将sizeCtl置为-1，然后初始化，初始化后再讲sizeCtl改回原来大小。初始化过程中,如有其它线程也要存值，会被yield</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">            2、如果当前桶中没有数据，通过cas将数据存入</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">            3、如果桶中已有数据，通过synchronized锁住头节点</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">                    如果头节点hash=-1(MOVED),帮助扩容后，然后插入</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">                    如果头节点的hash大于等于0，说明是链表，如果有相等的key存在，覆盖老数据，否则，直接将新数据添加在链表末端；</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">                    如果头节点的hash小于0，说明是红黑树的虚根节点（-2），在红黑树上更新或者插入节点。插入时会通过cas改变根节点的lockState锁住根节点。</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">            4、当上一步是在链表插入数据时，判断链表个数达到超过树化阈值8，超达到则将链表转换成树。转化成树的时候会先判断，当前数组大小是否达到最小树化容量值大小，如果没有，则进行扩容，将数组扩容为原来大小的两倍。</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">            5、针对插入情况，最后会调用addCount方法判断是否达到扩容大小，进行扩容。如果已经在扩容，则加入扩容阵营一起扩容</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">                    </span></div><div><span style="font-size: 9pt;"><br clear="none"/></span></div><div><span style="font-size: 9pt;"><br clear="none"/></span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">遗留问题：</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    1、构造函数中初始容量值扩大为1.5倍+1再调用tableSize方法计算大小？</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">        有这个疑问纯粹是因为有了HashMap固有思想的影响，下意识以为所有ConcurrentHashMap也是和HashMap一个套路。仔细查看就会发现，虽然它同HashMap一样，提供了带负载因子的构造函数，但是这个负载因子只是在构造函数中使用了一下，压根儿就没存，也没有loadFactor成员变量。        </span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">        先解释为何扩大为1.5倍，ConcurrentHashMap没有负载因子成员变量，但是它有负载因子的概念，这个默认值同样是0.75，且不可更改，扩大1.5倍就是囊括了负载因子，相当于替我们考虑了负载因子，我们只用考虑有多少数据就行，把负载因子从HashMap 的白盒，变成了ConcurrentHashMap的白盒。举个例子吧，如果我们预估数据量为15，HashMap的初始化容量为16，存到12时就会引发一次扩容；所以如果你不想让它扩容，你就得考虑负载因子，传入的初始值就是预期大小除以负载因子；而ConcuurentHashMap不用用户考虑负载因子，直接替我们考虑了，看一下那个带负载因子的构造函数，直接是预估大小除以负载因子，传入16，直接初始化为32；</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;"><span>    </span><span>    sizeCtl 构造函数中会被初始化为容量大小，在数组初始化后，会被改成</span></span><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">n - (n &gt;&gt;&gt; 2);相当于sizeCtl乘以0.75，也就是负载容量，后续存数据时，如果元素个数达到了sizeCtl大小，则进行扩容</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">        再解释一下为什么要+1，感觉这个纯粹是为了防止构造函数初始化容量传入个0，初始化一个大小为0 的数组，后续取值时会引发数组越界问题。</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    2</span><span style="font-size: 9pt;"><span style="font-family: Monaco; font-size: 9pt; color: rgb(227, 0, 0);">、方法中大量使用cas,但是偏移量的计算是static的，对象的属性偏移量为什么可以通过static获得？</span></span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    3、插入时锁park后的唤醒问题</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">        只有在先有一个线程加了读锁，后有一个线程加了写锁的情况下，加写锁的线程才会被park,如果后续又有多个读线程进入，一直等到最后一个读线程执行完才会唤醒写线程</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">    4、putTreeVal之前已经锁了头结点，为什么还要lockRoot</span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">        此处是为了解决读写线程并发的问题，如果只是多个写线程，只锁头结点就可以了，但是读写并发，如果不再lockRoot，读写就退化成了HashMap了</span></div><div><span style="font-size: 9pt;"><br clear="none"/></span></div><div><span style="font-size: 9pt; color: rgb(65, 173, 28); font-family: Monaco;">参考：</span></div><div><span style="font-size: 9pt;"><a href="https://www.cnblogs.com/christmad/p/11385863.html" shape="rect" style="font-size: 9pt; font-family: Monaco;">https://www.cnblogs.com/christmad/p/11385863.html</a></span></div><div><a href="https://www.cnblogs.com/godtrue/p/6341473.html" shape="rect">https://www.cnblogs.com/godtrue/p/6341473.html</a></div><div>hashMap8并发问题 <a href="https://blog.csdn.net/fumitzuki/article/details/82760236" shape="rect">https://blog.csdn.net/fumitzuki/article/details/82760236</a></div><div>ThreadLocalRandom  <a href="https://www.jianshu.com/p/9cfb2b65c266">https://www.jianshu.com/p/9cfb2b65c266</a></div></span>
</div></body></html> 