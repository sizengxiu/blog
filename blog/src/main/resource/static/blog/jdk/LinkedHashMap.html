<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="495"/>

<div>
<span><div>初印象：LinkedHashMap是一个有序的Map</div><div><br/></div><div><img src="LinkedHashMap_files/LinkedHashMap.png" type="image/png" data-filename="LinkedHashMap.png"/></div><div>1、注释</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* &lt;p&gt;Hash table and linked list implementation of the &lt;tt&gt;Map&lt;/tt&gt; interface,</div><div>* with predictable iteration order.  <font color="#A600C4">This implementation differs from</font></div><div><font color="#A600C4">* &lt;tt&gt;HashMap&lt;/tt&gt; in that it maintains a doubly-linked list running through</font></div><div>* all of its entries.  This linked list defines the iteration ordering,</div><div>* which is normally the order in which keys were inserted into the map</div><div>* (&lt;i&gt;<font color="#BC0058">insertion-orde</font>r&lt;/i&gt;).  Note that insertion order is not affected</div><div>* if a key is &lt;i&gt;re-inserted&lt;/i&gt; into the map.  (A key &lt;tt&gt;k&lt;/tt&gt; is</div><div>* reinserted into a map &lt;tt&gt;m&lt;/tt&gt; if &lt;tt&gt;m.put(k, v)&lt;/tt&gt; is invoked when</div><div>* &lt;tt&gt;m.containsKey(k)&lt;/tt&gt; would return &lt;tt&gt;true&lt;/tt&gt; immediately prior to</div><div>* the invocation.)</div><div><br/></div><div>public class LinkedHashMap&lt;K,V&gt;</div><div>    extends HashMap&lt;K,V&gt;</div><div>    implements Map&lt;K,V&gt;</div><div>{</div><div>/**</div><div>* HashMap.Node subclass for normal LinkedHashMap entries.</div><div>*/</div><div>//内部存储的是Entry结构体，其实就是加了头尾指针的加强版Node</div><div>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {</div><div>    Entry&lt;K,V&gt; before, after;</div><div>    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</div><div>        super(hash, key, value, next);</div><div>    }</div><div>}</div><div><br/></div><div>/**</div><div>* The head (eldest) of the doubly linked list.</div><div>*/</div><div>transient LinkedHashMap.Entry&lt;K,V&gt; head;</div><div><br/></div><div><br/></div><div>/**</div><div>* The tail (youngest) of the doubly linked list.</div><div>*/</div><div>transient LinkedHashMap.Entry&lt;K,V&gt; tail;</div></div><div>LinkedHashMap是一个继承自HashMap的双端队列。它保证了插入顺序，二次插入时，以第一次插入顺序为准。</div><div><br/></div><div>接下来我开始处于了懵逼状态，因为我看到LinkedHashMap竟然没有重写put方法，那它是怎么记录插入顺序的？</div><div>赶紧写个例子测试一下，是不是我对LinkedHashMap的认知出现了错误</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class LinkedHashMapTest {</div><div>    public static void main(String[] args){</div><div>        LinkedHashMap&lt;Integer,Integer&gt; map=new LinkedHashMap(16);</div><div>        map.put(1,1);</div><div>        map.put(3,3);</div><div>        map.put(2,2);</div><div>        map.put(3,3);</div><div>        System.out.println(map.toString());</div><div>    }</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//输出</span></div><div>{1=1, 3=3, 2=2}</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">没毛病，那应该就是迭代器做了手脚？不对，前后指针必然只能在存数据时保存，如果可以在迭代器中再做手脚，那HashMap自己就可以这么干了。那先看一下迭代器吧（后记：全都看完之后，才返现这个时候应该先看put方法，先看迭代器思路有点被打乱的感觉）</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</div><div>    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div>    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</div><div>}</div></div><div>返回的是它自己的内部类entrySet</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    public final int size()                 { return size; }</div><div>    public final void clear()               { HashMap.this.clear(); }</div><div>    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</div><div>        return new EntryIterator();</div><div>    }</div><div>只贴了一部分</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">HashMapde的entrySet的迭代器是EntryIterator,LinkedHashMap的entrySet也是EntryIterator,只不过此EntryIterator非彼EntryIterator,HashMap的EntryIterator是有final修饰的，是不可被继承的，不能被继承？那就自己实现一个好了</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class LinkedEntryIterator extends LinkedHashIterator</div><div>    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }</div><div>}</div></div><div>它继承了LinkedHashIterator，按一般来说，LinkedHashIterator会继承HashIterator（abstract修饰，没有final修饰），但是并没有</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>abstract class LinkedHashIterator {</div><div>    LinkedHashMap.Entry&lt;K,V&gt; next;</div><div>    LinkedHashMap.Entry&lt;K,V&gt; current;</div><div>    int expectedModCount;</div><div><br/></div><div><br/></div><div>    LinkedHashIterator() {</div><div>        next = head;</div><div>        expectedModCount = modCount;</div><div>        current = null;</div><div>    }</div><div><br/></div><div><br/></div><div>    public final boolean hasNext() {</div><div>        return next != null;</div><div>    }</div><div><br/></div><div><br/></div><div>    final LinkedHashMap.Entry&lt;K,V&gt; nextNode() {</div><div>        LinkedHashMap.Entry&lt;K,V&gt; e = next;</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>        if (e == null)</div><div>            throw new NoSuchElementException();</div><div>        current = e;</div><div>        next = e.after;</div><div>        return e;</div><div>    }</div><div><br/></div><div><br/></div><div>    public final void remove() {</div><div>        Node&lt;K,V&gt; p = current;</div><div>        if (p == null)</div><div>            throw new IllegalStateException();</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>        current = null;</div><div>        K key = p.key;</div><div>        removeNode(hash(key), key, null, false, false);</div><div>        expectedModCount = modCount;</div><div>    }</div><div>}</div></div><div>nextNode()方法中直接使用后继指针了。并无任何特殊。</div><div>那应该就是HashMap的put方法中调用了多态方法，检查，最大的多态机会是putVal方法，然而putVal没有重写，仔细查找，最终是newNode方法进行了多态调用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) {</div><div>    LinkedHashMap.Entry&lt;K,V&gt; p =</div><div>        new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</div><div>    linkNodeLast(p);</div><div>    return p;</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//前后指针的挂在逻辑非常简单，当前节点的前驱节点指向原来的尾部节点，原尾结点的后继指针指向新增结点</span></div><div>private void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) {</div><div>    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</div><div>    tail = p;</div><div>    if (last == null)</div><div>        head = p;</div><div>    else {</div><div>        p.before = last;</div><div>        last.after = p;</div><div>    }</div><div>}</div></div><div><br/></div></span>
</div></body></html> 