<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="511"/>

<div>
<span><div>1、成员变量</div><div><br/></div><div>看完ArraList代码之后，再来看LinkedList，代码就感觉很好理解了。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>transient int size = 0;//元素个数</div><div>transient Node&lt;E&gt; first;//指向头结点</div><div>transient Node&lt;E&gt; last;//指向尾结点</div></div><div>成员变量只有3个，看名字就知道是个链表。看看Node的具体结构：</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class Node&lt;E&gt; {</div><div>    E item;</div><div>    Node&lt;E&gt; next;</div><div>    Node&lt;E&gt; prev;</div><div><br/></div><div><br/></div><div>    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) {</div><div>        this.item = element;</div><div>        this.next = next;</div><div>        this.prev = prev;</div><div>    }</div><div>}</div></div><div>Node是ArrayList的静态内部类，标准的双向链表。</div><div><br/></div><div>2、添加数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean add(E e) {</div><div>    linkLast(e);</div><div>    return true;</div><div>}</div><div>void linkLast(E e) {</div><div>    final Node&lt;E&gt; l = last;</div><div>    final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null);</div><div>    last = newNode;</div><div>    if (l == null)</div><div>        first = newNode;</div><div>    else</div><div>        l.next = newNode;</div><div>    size++;</div><div>    modCount++;</div><div>}</div></div><div>直接把新节点挂在最后结点上，然后modCount++（同ArrayList一样，迭代器中使用），操作简单时间复杂度O(1)</div><div><br/></div><div>再看看在指定位置添加元素</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void add(int index, E element) {</div><div>    checkPositionIndex(index);</div><div>    if (index == size)</div><div>        linkLast(element);</div><div>    else</div><div>        linkBefore(element, node(index));</div><div>}</div></div><div>LinkBefore与LinkLast大同小异，此处调用了一个node方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Node&lt;E&gt; node(int index) {</div><div>      //位置小于长度的一半，则从头开始</div><div>    if (index &lt; (size &gt;&gt; 1)) {</div><div>        Node&lt;E&gt; x = first;</div><div>        for (int i = 0; i &lt; index; i++)</div><div>            x = x.next;</div><div>        return x;</div><div>    } else {//大于长度的一半，从尾部开始</div><div>        Node&lt;E&gt; x = last;</div><div>        for (int i = size - 1; i &gt; index; i--)</div><div>            x = x.prev;</div><div>        return x;</div><div>    }</div><div>}</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">判断了要插入的位置是离头结点近还是尾结点近，一个判断使得时间缩短了一半，双向链表优势再次体现。</span></div><div><span style="font-size: 9pt;"><br/></span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">3、删除元素</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean remove(Object o) {</div><div>    if (o == null) {</div><div>        for (Node&lt;E&gt; x = first; x != null; x = x.next) {</div><div>            if (x.item == null) {</div><div>                unlink(x);</div><div>                return true;</div><div>            }</div><div>        }</div><div>    } else {</div><div>        for (Node&lt;E&gt; x = first; x != null; x = x.next) {</div><div>            if (o.equals(x.item)) {</div><div>                unlink(x);</div><div>                return true;</div><div>            }</div><div>        }</div><div>    }</div><div>    return false;</div><div>}</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">和ArrayList的删除方法几乎一模一样，再看unlink</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>E unlink(Node&lt;E&gt; x) {</div><div>    // assert x != null;</div><div>    final E element = x.item;</div><div>    final Node&lt;E&gt; next = x.next;</div><div>    final Node&lt;E&gt; prev = x.prev;</div><div><br/></div><div><br/></div><div>    if (prev == null) {</div><div>        first = next;</div><div>    } else {</div><div>        prev.next = next;</div><div>        x.prev = null;</div><div>    }</div><div><br/></div><div><br/></div><div>    if (next == null) {</div><div>        last = prev;</div><div>    } else {</div><div>        next.prev = prev;</div><div>        x.next = null;</div><div>    }</div><div><br/></div><div><br/></div><div>    x.item = null;</div><div>    size--;</div><div>    modCount++;</div><div>    return element;</div><div>}</div></div><div>一通前后指针修改操作，日常链表移除结点而已。再现modCount++;</div><div><br/></div><div>3、迭代器</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private class ListItr implements ListIterator&lt;E&gt; {</div><div>    private Node&lt;E&gt; lastReturned;</div><div>    private Node&lt;E&gt; next;</div><div>    private int nextIndex;</div><div>    private int expectedModCount = modCount;</div><div><br/></div><div><br/></div><div>    ListItr(int index) {</div><div>        // assert isPositionIndex(index);</div><div>        next = (index == size) ? null : node(index);</div><div>        nextIndex = index;</div><div>    }</div><div><br/></div><div><br/></div><div>    public boolean hasNext() {</div><div>        return nextIndex &lt; size;</div><div>    }</div><div><br/></div><div><br/></div><div>    public E next() {</div><div>        checkForComodification();</div><div>        if (!hasNext())</div><div>            throw new NoSuchElementException();</div><div><br/></div><div><br/></div><div>        lastReturned = next;</div><div>        next = next.next;</div><div>        nextIndex++;</div><div>        return lastReturned.item;</div><div>    }</div><div><br/></div><div><br/></div><div>    public boolean hasPrevious() {</div><div>        return nextIndex &gt; 0;</div><div>    }</div><div><br/></div><div><br/></div><div>    public E previous() {</div><div>        checkForComodification();</div><div>        if (!hasPrevious())</div><div>            throw new NoSuchElementException();</div><div><br/></div><div><br/></div><div>        lastReturned = next = (next == null) ? last : next.prev;</div><div>        nextIndex--;</div><div>        return lastReturned.item;</div><div>    }</div><div><br/></div><div><br/></div><div>    public int nextIndex() {</div><div>        return nextIndex;</div><div>    }</div><div><br/></div><div><br/></div><div>    public int previousIndex() {</div><div>        return nextIndex - 1;</div><div>    }</div><div><br/></div><div><br/></div><div>    public void remove() {</div><div>        checkForComodification();</div><div>        if (lastReturned == null)</div><div>            throw new IllegalStateException();</div><div><br/></div><div><br/></div><div>        Node&lt;E&gt; lastNext = lastReturned.next;</div><div>        unlink(lastReturned);</div><div>        if (next == lastReturned)</div><div>            next = lastNext;</div><div>        else</div><div>            nextIndex--;</div><div>        lastReturned = null;</div><div>        expectedModCount++;</div><div>    }</div><div><br/></div><div><br/></div><div>    public void set(E e) {</div><div>        if (lastReturned == null)</div><div>            throw new IllegalStateException();</div><div>        checkForComodification();</div><div>        lastReturned.item = e;</div><div>    }</div><div><br/></div><div><br/></div><div>    public void add(E e) {</div><div>        checkForComodification();</div><div>        lastReturned = null;</div><div>        if (next == null)</div><div>            linkLast(e);</div><div>        else</div><div>            linkBefore(e, next);</div><div>        nextIndex++;</div><div>        expectedModCount++;</div><div>    }</div><div><br/></div><div><br/></div><div>    public void forEachRemaining(Consumer&lt;? super E&gt; action) {</div><div>        Objects.requireNonNull(action);</div><div>        while (modCount == expectedModCount &amp;&amp; nextIndex &lt; size) {</div><div>            action.accept(next.item);</div><div>            lastReturned = next;</div><div>            next = next.next;</div><div>            nextIndex++;</div><div>        }</div><div>        checkForComodification();</div><div>    }</div><div><br/></div><div><br/></div><div>    final void checkForComodification() {</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>    }</div><div>}</div></div><div>和ArrayList有点不一样的是它只有一个ListItr迭代器，而ArrayList有两个。但是它这一个迭代器提供了和ArrayList的两个迭代器相同的功能，那问题来了？既然提供一样的功能，为什么一个提供两个迭代器，一个提供一个迭代器？倒不是说一个提供两个，一个提供一个，他们两个有一个共同的父类（祖先）AbstarctList，它有一个公共方法Iterator,只不过ArrayList对它进行了重写，但是LinkedList没有提供实现直接使用父类的而已。</div><div>看一下AbstractList的Iterator方法：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//这个迭代器，AbstractList自己提供了实现，ArrayList和LinkedList都提供重写实现，所以不再赘述</div><div>public ListIterator&lt;E&gt; listIterator(final int index) {</div><div>    rangeCheckForAdd(index);</div><div>    return new ListItr(index);</div><div>}</div><div>//重点看下这个普通迭代器</div><div>public Iterator&lt;E&gt; iterator() {</div><div>    return new Itr();</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//下面是实现</span></div><div>private class Itr implements Iterator&lt;E&gt; {</div><div>    int cursor = 0;</div><div>    int lastRet = -1;</div><div>    int expectedModCount = modCount;</div><div><br/></div><div>    public boolean hasNext() {</div><div>        return cursor != size();</div><div>    }</div><div>    public E next() {</div><div>        checkForComodification();</div><div>        try {</div><div>            int i = cursor;</div><div>            E next = <b><font color="#A600C4">get(i);</font></b></div><div>            lastRet = i;</div><div>            cursor = i + 1;</div><div>            return next;</div><div>        } catch (IndexOutOfBoundsException e) {</div><div>            checkForComodification();</div><div>            throw new NoSuchElementException();</div><div>        }</div><div>    }</div><div>    public void remove() {</div><div>        if (lastRet &lt; 0)</div><div>            throw new IllegalStateException();</div><div>        checkForComodification();</div><div>        try {</div><div>            AbstractList.this.remove(lastRet);</div><div>            if (lastRet &lt; cursor)</div><div>                cursor--;</div><div>            lastRet = -1;</div><div>            expectedModCount = modCount;</div><div>        } catch (IndexOutOfBoundsException e) {</div><div>            throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div><div>    final void checkForComodification() {</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>    }</div><div>}</div></div><div>Itr这个迭代器的代码和ArrayList如出一辙，不知道为什么ArrayList要再重写一遍。注意next方法中的标亮部分，获取下一元素的时候，调用了get(i)函数，ArrayList倒无所谓反正O(1)时间就可以找到，但是LinkedList去调用这个函数，效率很低啊，为什么不重写？直接记录当前指针多快啊。再次对比两者的继承关系，发现LinkedList还继承了AbstractSequenceList,看看这货的说明</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>* This class provides a skeletal implementation of the &lt;tt&gt;List&lt;/tt&gt;</div><div>* interface to minimize the effort required to implement this interface</div><div>* backed by a &quot;sequential access&quot; data store (such as a linked list).  For</div><div>* random access data (such as an array), &lt;tt&gt;AbstractList&lt;/tt&gt; should be used</div><div>* in preference to this class.&lt;p&gt;</div><div>*</div><div>* This class is the opposite of the &lt;tt&gt;AbstractList&lt;/tt&gt; class in the sense</div><div>* that it implements the &quot;random access&quot; methods (&lt;tt&gt;get(int index)&lt;/tt&gt;,</div><div>* &lt;tt&gt;set(int index, E element)&lt;/tt&gt;, &lt;tt&gt;add(int index, E element)&lt;/tt&gt; and</div><div>* &lt;tt&gt;remove(int index)&lt;/tt&gt;) on top of the list's list iterator, instead of</div><div>* the other way around.&lt;p&gt;</div><div>*</div><div>* To implement a list the programmer needs only to extend this class and</div><div>* provide implementations for the &lt;tt&gt;listIterator&lt;/tt&gt; and &lt;tt&gt;size&lt;/tt&gt;</div><div>* methods.  For an unmodifiable list, the programmer need only implement the</div><div>* list iterator's &lt;tt&gt;hasNext&lt;/tt&gt;, &lt;tt&gt;next&lt;/tt&gt;, &lt;tt&gt;hasPrevious&lt;/tt&gt;,</div><div>* &lt;tt&gt;previous&lt;/tt&gt; and &lt;tt&gt;index&lt;/tt&gt; methods.&lt;p&gt;</div></div><div>大意就是AbstractSequenceList专门设计用来处理sequential access顺序存取的链表，第三段说出了继承了它的顺序存取链表只需要提供Listiterator和size方法就可以了，无需再提供Iterator实现。看看它怎么做到的：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Iterator&lt;E&gt; iterator() {</div><div>    return listIterator();</div><div>}</div><div>public ListIterator&lt;E&gt; listIterator() {</div><div>    return listIterator(0);</div><div>}</div><div>public ListIterator&lt;E&gt; listIterator(final int index) {</div><div>    rangeCheckForAdd(index);</div><div>    return new ListItr(index);</div><div>}</div></div><div>妥妥的请求转发，简单粗暴。说白了就是它的普通Iterator返回</div><div><br/></div><div>4、获取数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public E get(int index) {</div><div>    checkElementIndex(index);</div><div>    return node(index).item;</div><div>}</div></div><div>直接调用的node方法，删除时已提起过，不再赘述。</div><div><br/></div><div>5、作为队列提供的方法</div><div>    pop/push/offer等，比较简单，不再贴上代码</div><div><br/></div><div>6、序列化</div><div>    它的成员变量first和last都使用了transient，此处原因和ArrayList略有不同，由于是用链表存储，所以序列化时要将每个结点都自己写入一遍，和ArrayList的存在不适用的空间略有不同。</div></span>
</div></body></html> 