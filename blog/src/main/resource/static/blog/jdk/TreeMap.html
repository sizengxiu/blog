<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="492"/>

<div>
<span><div>初印象：可以排序的Map</div><div>不同于LinkedHashMap继承于HashMap,TreeMap和HashMap处于继承树的同一级</div><div><img src="TreeMap_files/TreeMap.png" type="image/png" data-filename="TreeMap.png"/></div><div><br/></div><div>1、构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* A Red-Black tree based {@link NavigableMap} implementation.（基于红黑树）</div><div>* The map is sorted according to the {@linkplain Comparable natural</div><div>* ordering} of its keys, or by a {@link Comparator} provided at map（根据key的自然顺序或者给定的排序器）</div><div>* creation time, depending on which constructor is used.</div><div>public class TreeMap&lt;K,V&gt;</div><div>    extends AbstractMap&lt;K,V&gt;</div><div>    implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable</div><div>{</div><div>    /**</div><div>     * The comparator used to maintain order in this tree map, or</div><div>     * null if it uses the natural ordering of its keys.</div><div>     *</div><div>     * @serial</div><div>     */</div><div>    private final Comparator&lt;? super K&gt; comparator;</div><div><br/></div><div><br/></div><div>    private transient Entry&lt;K,V&gt; root;//根节点</div></div><div>提供了三个构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public TreeMap() {</div><div>    comparator = null;</div><div>}</div><div><br/></div><div>public TreeMap(Comparator&lt;? super K&gt; comparator) {</div><div>    this.comparator = comparator;</div><div>}</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>public TreeMap(Map&lt;? extends K, ? extends V&gt; m) {</div><div>    comparator = null;</div><div>    putAll(m);</div><div>}</div></div><div>第一个第二个区别是第二个传入了一个比较器</div><div><br/></div><div>上面看到了根节点的类型时Entry，看一下Entry结构，此处的Entry不再是个接口，而是个实体类</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; {</div><div>    K key;</div><div>    V value;</div><div>    Entry&lt;K,V&gt; left;</div><div>    Entry&lt;K,V&gt; right;</div><div>    Entry&lt;K,V&gt; parent;</div><div>    boolean color = BLACK;</div><div><br/></div><div><br/></div><div>    Entry(K key, V value, Entry&lt;K,V&gt; parent) {</div><div>        this.key = key;</div><div>        this.value = value;</div><div>        this.parent = parent;</div><div>    }</div><div><br/></div><div>    public K getKey() {</div><div>        return key;</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    public V getValue() {</div><div>        return value;</div><div>    }</div><div><br/></div><div>    public V setValue(V value) {</div><div>        V oldValue = this.value;</div><div>        this.value = value;</div><div>        return oldValue;</div><div>    }</div><div><br/></div><div><br/></div><div>    public boolean equals(Object o) {</div><div>        if (!(o instanceof Map.Entry))</div><div>            return false;</div><div>        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div><br/></div><div><br/></div><div>        return valEquals(key,e.getKey()) &amp;&amp; valEquals(value,e.getValue());</div><div>    }</div><div><br/></div><div><span>    //加亮表强调，此处用的是key的hash码和value的hash码相异或</span><br/></div><div><font color="#EB0073">    public int hashCode() {</font></div><div><font color="#EB0073">        int keyHash = (key==null ? 0 : key.hashCode());</font></div><div><font color="#EB0073">        int valueHash = (value==null ? 0 : value.hashCode());</font></div><div><font color="#EB0073">        return keyHash ^ valueHash;</font></div><div><font color="#EB0073">    }</font></div><div><br/></div><div><br/></div><div>    public String toString() {</div><div>        return key + &quot;=&quot; + value;</div><div>    }</div><div>}</div></div><div>左右指针父指针，典型的树节点结构，还有一个颜色，默认值是黑色，红黑树节点实锤了</div><div><br/></div><div>2、数据存储</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V put(K key, V value) {</div><div>    Entry&lt;K,V&gt; t = root;</div><div>    if (t == null) {</div><div>        compare(key, key); <font color="#A600C4">// type (and possibly null) check</font></div><div><br/></div><div>        root = new Entry&lt;&gt;(key, value, null);</div><div>        size = 1;</div><div>        modCount++;</div><div>        return null;</div><div>    }</div><div>    int cmp;</div><div>    Entry&lt;K,V&gt; parent;</div><div>    // split comparator and comparable paths</div><div>    Comparator&lt;? super K&gt; cpr = comparator;</div><div>    if (cpr != null) {</div><div><span>    </span><span>    //从根节点开始，如果大于结点值则从右子树遍历，小于则从左子树遍历，相等说明是重复存入，修改值后直接返回。</span><br/></div><div>        do {</div><div>            parent = t;</div><div>            cmp = cpr.compare(key, t.key);</div><div>            if (cmp &lt; 0)</div><div>                t = t.left;</div><div>            else if (cmp &gt; 0)</div><div>                t = t.right;</div><div>            else</div><div>                return t.setValue(value);</div><div>        } while (t != null);</div><div>    }</div><div>//else中的操作和上面相同，只是此处使用的是key的比较器</div><div>    else {</div><div>        if (key == null)</div><div>            throw new NullPointerException();</div><div>        @SuppressWarnings(&quot;unchecked&quot;)</div><div>            Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key;</div><div>        do {</div><div>            parent = t;</div><div>            cmp = k.compareTo(t.key);</div><div>            if (cmp &lt; 0)</div><div>                t = t.left;</div><div>            else if (cmp &gt; 0)</div><div>                t = t.right;</div><div>            else</div><div>                return t.setValue(value);</div><div>        } while (t != null);</div><div>    }</div><div>    Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent);</div><div>    if (cmp &lt; 0)</div><div>        parent.left = e;</div><div>    else</div><div>        parent.right = e;</div><div><span>    //红黑树的平衡操作</span><br/></div><div>    fixAfterInsertion(e);</div><div>    size++;</div><div>    modCount++;</div><div>    return null;</div><div>}</div></div><div>根节点为空时调用了compare方法，自己跟自己比较有什么意义？暂未想到，那就继续看</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>//TreeMap构造器中指定了比较器则使用指定的，没指定则使用key的比较器</div><div>final int compare(Object k1, Object k2) {</div><div>    return comparator==null ? ((Comparable&lt;? super K&gt;)k1).compareTo((K)k2)</div><div>        : comparator.compare((K)k1, (K)k2);</div><div>}</div></div><div>按照上面的代码逻辑，如果构造器不指定比较器，key也没有比较器，岂不是会空指针？</div><div>写个例子测试一下：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class TreeMapTest {</div><div>    public void test(){</div><div>        TreeMap&lt;Key,Object&gt; map=new TreeMap&lt;&gt;();</div><div>        map.put(new Key(1),null);</div><div>    }</div><div>    private class Key{</div><div>        int val;</div><div>        public Key(int val){</div><div>            this.val=val;</div><div>        }</div><div>    }</div><div>    public static void main(String[] args){</div><div>        TreeMapTest t=new TreeMapTest();</div><div>        t.test();</div><div>    }</div><div>}</div></div><div>果然运行异常，但不是空指针异常，而是类型转换异常。仔细看先上面的compare方法，先是类型强转才调用方法，确实应该是类型转换异常；且该方法调用后有行简单的注释，类型和空指针检查；说白了就是比较器的合法性检测，如果有问题让它再第一次存储数据时就抛出异常；如果没有这个比较，这个异常会到后面添加数据时才抛出，显然是不合适的。</div><div>平地起惊雷，我辈之楷模。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>Exception in thread &quot;main&quot; java.lang.ClassCastException: com.si.jdk.TreeMapTest$Key cannot be cast to java.lang.Comparable</div><div>    at java.util.TreeMap.compare(TreeMap.java:1294)</div><div>    at java.util.TreeMap.put(TreeMap.java:538)</div><div>    at com.si.jdk.TreeMapTest.test(TreeMapTest.java:12)</div><div>    at com.si.jdk.TreeMapTest.main(TreeMapTest.java:8)</div></div><div>修改下内部类，让它实现构造器接口，再次运行，果然正常。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private class Key implements Comparable&lt;Key&gt;{</div><div>    int val;</div><div>    public Key(int val){</div><div>        this.val=val;</div><div>    }</div><div><br/></div><div>    @Override</div><div>    public int compareTo(Key o) {</div><div>        return 0;</div><div>    }</div><div>}</div></div><div><br/></div><div>瞅一眼 ，红黑树的平衡操作，看看能不能看懂。红黑树基础的操作可参看（ <a href="https://www.jianshu.com/p/104fa73c81b3">https://www.jianshu.com/p/104fa73c81b3</a>）</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void fixAfterInsertion(Entry&lt;K,V&gt; x) {</div><div>    x.color = RED;//新插入结点为红色结点</div><div><br/></div><div><span>    //父节点红色</span><br/></div><div>    while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) {</div><div><span>    </span><span>    //父节点是祖父结点的左孩子</span><br/></div><div>        if (parentOf(x) == leftOf(parentOf(parentOf(x)))) {</div><div>            Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x)));//右边的叔父结点</div><div><span>    </span><span>    </span><span>    //这是最简单的情况</span><br/></div><div>            if (colorOf(y) == RED) {//叔父结点为红色</div><div><span>    </span><span>    </span><span>    </span><span>    //父节点和叔父结点都变为黑色，祖父结点变为红色</span><br/></div><div>                setColor(parentOf(x), BLACK);</div><div>                setColor(y, BLACK);</div><div>                setColor(parentOf(parentOf(x)), RED);</div><div>                x = parentOf(parentOf(x));//x指向了祖父结点</div><div>            } else {//叔父结点为黑色</div><div><span>    </span><span>    </span><span>    </span><span>    </span>//此为左右情况，先左旋变成左左情况</div><div>                if (x == rightOf(parentOf(x))) {</div><div>                    x = parentOf(x);</div><div>                    rotateLeft(x);</div><div>                }</div><div><span>    </span><span>    </span><span>    </span><span>    //左左情况，父节点变黑，祖父变红，右旋</span><br/></div><div>                setColor(parentOf(x), BLACK);</div><div>                setColor(parentOf(parentOf(x)), RED);</div><div>                rotateRight(parentOf(parentOf(x)));</div><div>            }</div><div>        } else {//父节点是祖父结点的右孩子，这种情况是上面if情况的镜像，不再赘述</div><div>            Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x)));</div><div>            if (colorOf(y) == RED) {</div><div>                setColor(parentOf(x), BLACK);</div><div>                setColor(y, BLACK);</div><div>                setColor(parentOf(parentOf(x)), RED);</div><div>                x = parentOf(parentOf(x));</div><div>            } else {</div><div>                if (x == leftOf(parentOf(x))) {</div><div>                    x = parentOf(x);</div><div>                    rotateRight(x);</div><div>                }</div><div>                setColor(parentOf(x), BLACK);</div><div>                setColor(parentOf(parentOf(x)), RED);</div><div>                rotateLeft(parentOf(parentOf(x)));</div><div>            }</div><div>        }</div><div>    }</div><div>    root.color = BLACK;</div><div>}</div></div><div>貌似能看懂，哈哈</div><div><br/></div><div>3、遍历</div><div>已经构建好了红黑树，可以猜测所谓的按顺序遍历无非就是平衡二叉树的中序遍历。</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">还是HashMap迭代器的套路，过程不多着笔墨，要看的核心是最后的</span><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">successor方法</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</div><div>    EntrySet es = entrySet;</div><div>    return (es != null) ? es : (entrySet = new EntrySet());</div><div>}</div><div>class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    public Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</div><div>        return new EntryIterator(getFirstEntry());</div><div>    }</div><div><br/></div><div><br/></div><div>final class EntryIterator extends PrivateEntryIterator&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    EntryIterator(Entry&lt;K,V&gt; first) {</div><div>        super(first);</div><div>    }</div><div>    public Map.Entry&lt;K,V&gt; next() {</div><div>        return nextEntry();</div><div>    }</div><div>}</div><div><br/></div><div><br/></div><div>abstract class PrivateEntryIterator&lt;T&gt; implements Iterator&lt;T&gt; {</div><div>    Entry&lt;K,V&gt; next;</div><div>    Entry&lt;K,V&gt; lastReturned;</div><div>    int expectedModCount;</div><div><br/></div><div><br/></div><div>    PrivateEntryIterator(Entry&lt;K,V&gt; first) {</div><div>        expectedModCount = modCount;</div><div>        lastReturned = null;</div><div>        next = first;</div><div>    }</div><div><br/></div><div><br/></div><div>    public final boolean hasNext() {</div><div>        return next != null;</div><div>    }</div><div><br/></div><div>    final Entry&lt;K,V&gt; nextEntry() {</div><div>        Entry&lt;K,V&gt; e = next;</div><div>        if (e == null)</div><div>            throw new NoSuchElementException();</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>        next = successor(e);</div><div>        lastReturned = e;</div><div>        return e;</div><div>    }</div></div><div>看看实际干活的successor方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static &lt;K,V&gt; TreeMap.Entry&lt;K,V&gt; successor(Entry&lt;K,V&gt; t) {</div><div>    if (t == null)</div><div>        return null;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><span>    </span><span>    //下一个结点应该是当前节点右子树的最左结点（其实就是中序遍历）</span><br/></span></div><div>    else if (t.right != null) {</div><div>        Entry&lt;K,V&gt; p = t.right;</div><div>        while (p.left != null)</div><div>            p = p.left;</div><div>        return p;</div><div>    } else {//右子树为空，下一结点就是父节点</div><div>        Entry&lt;K,V&gt; p = t.parent;</div><div>        Entry&lt;K,V&gt; ch = t;</div><div>        while (p != null &amp;&amp; ch == p.right) {</div><div>            ch = p;</div><div>            p = p.parent;</div><div>        }</div><div>        return p;</div><div>    }</div><div>}</div></div><div><br/></div></span>
</div></body></html> 