<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="481"/>

<div>
<span><div>1、学习String从注释开始</div><div>先来看一下String类的前两段的说明</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>* The {@code String} class represents character strings. All</div><div>* string literals in Java programs, such as {@code &quot;abc&quot;}, are</div><div>* implemented as instances of this class.</div><div><font color="#7600D8">//Java中所有的字符串都是String对象</font></div><div>* &lt;p&gt;</div><div>* <font color="#000000">Strings are constant;</font> their values cannot be changed after they</div><div>* are created. String buffers support mutable strings.</div><div>* Because String objects are immutable they can be shared. </div><div><span style="font-size: 9pt; font-family: Monaco;"><font color="#7600D8">//String是不可修改的常量，因为它不可变所以可以共享（String常量池）。</font></span></div></div><div><br/></div><div>看一下类定义</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public <font color="#7600D8">final</font> class String</div><div>    implements java.io.Serializable, <font color="#41AD1C">Comparable</font>&lt;String&gt;, CharSequence {</div><div>    /** The value is used for character storage. */</div><div>    private final char value[];</div><div>    /** Cache the hash code for the string */</div><div>    private int hash; // Default to 0</div></div><div>String信息的存储是用的char[]数组，把String设计成不可变类，和它应该有不可分割的原因，毕竟数组的变化要求连续的空间，代价太高。</div><div><br/></div><div>2、构造函数</div><div>    String的构造函数个数目测有10+之多，此处只列举常用的几个</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    //无参构造函数</div><div>    public String() {</div><div>        this.value = &quot;&quot;.value;</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //接String的构造函数</span></div><div>    public String(String original) {</div><div>        this.value = original.value;</div><div>        this.hash = original.hash;</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //接收char数组的构造函数</span></div><div>    public String(char value[]) {</div><div>        this.value = Arrays.copyOf(value, value.length);</div><div>    }</div></div><div><br/></div><div>3、常用函数</div><div>charAt函数的时间复杂度O(1)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public char charAt(int index) {</div><div>        if ((index &lt; 0) || (index &gt;= value.length)) {</div><div>            throw new  StringIndexOutOfBoundsException(index);</div><div>        }</div><div>        return value[index];</div><div>    }</div></div><div><br/></div><div>查找字符串的位置，实现思路就是正常的一个一个字符去比较，时间复杂度较高O(m*n)</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public int indexOf(String str) {</div><div>        return indexOf(str, 0);</div><div>    }</div><div>    public int indexOf(String str, int fromIndex) {</div><div>        return indexOf(value, 0, value.length,</div><div>                str.value, 0, str.value.length, fromIndex);</div><div>    }</div><div>    static int indexOf(char[] source, int sourceOffset,  int sourceCount,</div><div>            char[] target, int targetOffset, int  targetCount,</div><div>            int fromIndex) {</div><div>        if (fromIndex &gt;= sourceCount) {</div><div>            return (targetCount == 0 ? sourceCount : -1);</div><div>        }</div><div>        if (fromIndex &lt; 0) {</div><div>            fromIndex = 0;</div><div>        }</div><div>        if (targetCount == 0) {</div><div>            return fromIndex;</div><div>        }</div><div>        char first = target[targetOffset];</div><div>        int max = sourceOffset + (sourceCount -  targetCount);</div><div>        for (int i = sourceOffset + fromIndex; i &lt;= max;  i++) {</div><div>            /* Look for first character. */</div><div>            if (source[i] != first) {</div><div>                while (++i &lt;= max &amp;&amp; source[i] != first);</div><div>            }</div><div>            /* Found first character, now look at the rest  of v2 */</div><div>            if (i &lt;= max) {</div><div>                int j = i + 1;</div><div>                int end = j + targetCount - 1;</div><div>                for (int k = targetOffset + 1; j &lt; end &amp;&amp;  source[j]</div><div>                        == target[k]; j++, k++);</div><div>                if (j == end) {</div><div>                    /* Found whole string. */</div><div>                    return i - sourceOffset;</div><div>                }</div><div>            }</div><div>        }</div><div>        return -1;</div><div>    }</div></div><div><br/></div><div>字符串比较，思路比较明确，见注释</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public boolean equals(Object anObject) {</div><div>        //先判断地地址相等</div><div>        if (this == anObject) {</div><div>            return true;</div><div>        }</div><div>        if (anObject instanceof String) {</div><div>            String anotherString = (String)anObject;</div><div>            int n = value.length;</div><div>            //长度不相等，肯定不相等，最后才挨个字符判断</div><div>            if (n == anotherString.value.length) {</div><div>                char v1[] = value;</div><div>                char v2[] = anotherString.value;</div><div>                int i = 0;</div><div>                while (n-- != 0) {</div><div>                    if (v1[i] != v2[i])</div><div>                        return false;</div><div>                    i++;</div><div>                }</div><div>                return true;</div><div>            }</div><div>        }</div><div>        return false;</div><div>    }</div></div><div><br/></div><div>intern()方法，是native的。这个方法返回字符串常量池中的String对象，如果常量池中不存在相等的String对象，则将该对象加到常量池中并返回。（<span style="color: rgb(134, 0, 164);">字符串常量是在堆区</span>）</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    /**</div><div>     * Returns a canonical representation for the string  object.</div><div>     * &lt;p&gt;</div><div>     * A pool of strings, initially empty, is maintained  privately by the</div><div>     * class {@code String}.</div><div>     * &lt;p&gt;</div><div>     * When the intern method is invoked, if the pool  already contains a</div><div>     * string equal to this {@code String} object as  determined by</div><div>     * the {@link #equals(Object)} method, then the string  from the pool is</div><div>     * returned. Otherwise, this {@code String} object is  added to the</div><div>     * pool and a reference to this {@code String} object  is returned.</div><div>     */</div><div>    public native String intern();</div></div><div><br/></div><div>4、字符串拼接</div><div>jdk1.8对字符串拼接有了改进，使用+拼接字符串等同于使用StringBuilder进行拼接。看一个例子</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class StringTest {</div><div>    public static void main(String[] args){</div><div>        String a=&quot;1&quot;+&quot;2&quot;;</div><div>        String b=&quot;3&quot;+a;</div><div>        System.out.println(a);</div><div>    }</div><div>}</div></div><div>编译之后，再反编译</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public class StringTest {</div><div>    public StringTest() {</div><div>    }</div><div>    public static void main(String[] args) {</div><div>        String a = &quot;12&quot;;</div><div>        (new StringBuilder()).append(&quot;3&quot;).append(a).toString();</div><div>        System.out.println(a);</div><div>    }</div><div>}</div></div><div>可以看到+号已被StringBuilder代替。</div><div><br/></div><div>来看一下StringBuilder.</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>只留下了注释的第一行。这个是可以修改的字符序列。和它一起的还有一个线程安全的的类StringBuffer,言下之意就是它是线程不安全的。</div><div>/**</div><div>* A mutable sequence of characters.  This class provides  an API compatible</div><div>* with {@code StringBuffer}, but with no guarantee of  synchronization.</div><div><br/></div><div>public final class StringBuilder</div><div>    extends AbstractStringBuilder</div><div>    implements java.io.Serializable, CharSequence</div><div>{</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    public StringBuilder() {</div><div>        super(16);</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    public StringBuilder(int capacity) {</div><div>        super(capacity);</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    public StringBuilder(String str) {</div><div>        super(str.length() + 16);</div><div>        append(str);</div><div>    }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>    public StringBuilder(CharSequence seq) {</div><div>        this(seq.length() + 16);</div><div>        append(seq);</div><div>    }</div></div><div>它的构造函数全部显示调用了父类的构造函数，实际的数据存储也是在父类中。看一下父类</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>abstract class AbstractStringBuilder implements  Appendable, CharSequence {</div><div>    /**</div><div>     * The value is used for character storage.</div><div>     */</div><div>    char[] value;</div><div>    /**</div><div>     * The count is the number of characters used.</div><div>     */</div><div>    int count;</div><div>    //构造函数中申请了空间</div><div>    AbstractStringBuilder(int capacity) {</div><div>        value = new char[capacity];</div><div>    }</div></div><div>又是数组进行存储的，凡是这种数组存储的，生成对象时最好给他一个预估的空间大小，不然后续可能会出现多次扩容，而扩容会涉及到新旧数组的数据复制，虽然没看也知道它调用的System.copyarray这个高校方法，但是再高效的方法都不如不调用来的损耗小。StringBuilder的构造函数都+16，就是对此的一个优化。</div><div>看一下StringBuilder的append方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public StringBuilder append(StringBuffer sb) {</div><div>        super.append(sb);//调用了父类的append</div><div>        return this;</div><div>    }</div></div><div>看一下父类的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public AbstractStringBuilder append(String str) {</div><div>        if (str == null)</div><div>            return appendNull();//拼一个“null”字符串</div><div>        int len = str.length();</div><div>        ensureCapacityInternal(count + len);//确保空间够用</div><div>        str.getChars(0, len, value, count);//内部实现就是调用System.arraycopy</div><div>        count += len;</div><div>        return this;</div><div>    }</div></div><div>传入str为空时 直接 return appendNull();</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    private AbstractStringBuilder appendNull() {</div><div>        int c = count;</div><div>        ensureCapacityInternal(c + 4);</div><div>        final char[] value = this.value;</div><div>        value[c++] = 'n';</div><div>        value[c++] = 'u';</div><div>        value[c++] = 'l';</div><div>        value[c++] = 'l';</div><div>        count = c;</div><div>        return this;</div><div>    }</div></div><div>appendNull会拼一个“null”字符串，不明白为啥这么做。这一点拼接字符串时需需注意。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    private void ensureCapacityInternal(int  minimumCapacity) {</div><div>        // overflow-conscious code</div><div>        if (minimumCapacity - value.length &gt; 0) {</div><div>            value = Arrays.copyOf(value,</div><div>                    newCapacity(minimumCapacity));</div><div>        }</div><div>    }</div><div>//每次扩大为原来的2倍+2长度，不够直接使用老长度+新字符串长度</div><div>    private int newCapacity(int minCapacity) {</div><div>        // overflow-conscious code</div><div>        int newCapacity = (value.length &lt;&lt; 1) + 2;</div><div>        if (newCapacity - minCapacity &lt; 0) {</div><div>            newCapacity = minCapacity;</div><div>        }</div><div>        return (newCapacity &lt;= 0 || MAX_ARRAY_SIZE -  newCapacity &lt; 0)</div><div>            ? hugeCapacity(minCapacity)</div><div>            : newCapacity;</div><div>    }</div></div><div><br/></div><div>delete和insert方法内部都是调用System.arraycopy实现，其余不常用方法暂不关注。</div><div><br/></div><div>瞅一眼StringBuffer,比StringBuilder多了个synchronized关键字，其余一样</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    public synchronized StringBuffer append(String str) {</div><div>        toStringCache = null;</div><div>        super.append(str);</div><div>        return this;</div><div>    }</div></div><div><br/></div></span>
</div></body></html> 