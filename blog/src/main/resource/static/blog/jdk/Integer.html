<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="499"/>

<div>
<span><div><span style="font-size: 14pt;">1、主要看久仰已久的Cache</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">   /**</font></div><div><font style="font-size: 12pt;">     * Cache to support the object identity semantics of  autoboxing for values between</font></div><div><font style="font-size: 12pt;">     * -128 and 127 (inclusive) as required by JLS.</font></div><div><font style="font-size: 12pt;">     *</font></div><div><font style="font-size: 12pt;">     * <font color="#41AD1C"><b>The cache is initialized on first usage. </b></font> The size  of the cache</font></div><div><font style="font-size: 12pt;">     * may be controlled by the {@code  -XX:AutoBoxCacheMax=&lt;size&gt;} option.</font></div><div><font style="font-size: 12pt;">     * During VM initialization,  java.lang.Integer.IntegerCache.high property</font></div><div><font style="font-size: 12pt;">     * may be set and saved in the private system  properties in the</font></div><div><font style="font-size: 12pt;">     * sun.misc.VM class.</font></div><div><font style="font-size: 12pt;">     */    </font></div><div><font style="font-size: 12pt;">    private static class IntegerCache {</font></div><div><font style="font-size: 12pt;">        static final int low = -128;</font></div><div><font style="font-size: 12pt;">        static final int high;</font></div><div><font style="font-size: 12pt;">        static final Integer cache[];</font></div><div><font style="font-size: 12pt;">        static {</font></div><div><font style="font-size: 12pt;">            // high value may be configured by property</font></div><div><font style="font-size: 12pt;">            int h = 127;</font></div><div><font style="font-size: 12pt;">            String integerCacheHighPropValue =</font></div><div><font style="font-size: 12pt;">                 sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);</font></div><div><font style="font-size: 12pt;">            if (integerCacheHighPropValue != null) {</font></div><div><font style="font-size: 12pt;">                try {</font></div><div><font style="font-size: 12pt;">                    int i =  parseInt(integerCacheHighPropValue);</font></div><div><font style="font-size: 12pt;">                    i = Math.max(i, 127);</font></div><div><font style="font-size: 12pt;">                    // Maximum array size is  Integer.MAX_VALUE</font></div><div><font style="font-size: 12pt;">                    h = Math.min(i, Integer.MAX_VALUE -  (-low) -1);</font></div><div><font style="font-size: 12pt;">                } catch( NumberFormatException nfe) {</font></div><div><font style="font-size: 12pt;">                    // If the property cannot be parsed  into an int, ignore it.</font></div><div><font style="font-size: 12pt;">                }</font></div><div><font style="font-size: 12pt;">            }</font></div><div><font style="font-size: 12pt;">            high = h;</font></div><div><font style="font-size: 12pt;">            cache = new Integer[(high - low) + 1];</font></div><div><font style="font-size: 12pt;">            int j = low;</font></div><div><font style="font-size: 12pt;">            for(int k = 0; k &lt; cache.length; k++)</font></div><div><font style="font-size: 12pt;">                cache[k] = new Integer(j++);</font></div><div><font style="font-size: 12pt;">            // range [-128, 127] must be interned (JLS7  5.1.7)</font></div><div><font style="font-size: 12pt;">            assert IntegerCache.high &gt;= 127;</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        private IntegerCache() {}</font></div><div><font style="font-size: 12pt;">    }</font></div></div><div><span style="font-size: 12pt;">它是Integer的一个静态内部类，只有三个成员变量和一个静态代码块。看看上面被单独标记的注释，第一次使用时才初始化，注意，内部类不会随着外部类的加载而加载，静态内部类也不会，而是再第一次使用时才加载。</span></div><div><span style="font-size: 12pt;">从静态代码块中可知，缓存的大小是可以通过设定JVM参数来修改的，默认情况下是[-128,127];看到有说不包含127的，从下面代码可以看出是包含的，关于这一点下面会测试。</span></div><div><span style="font-size: 12pt;">缓存有什么用？闭着眼睛从字面意思猜：缓存是为了提高效率，加快速度。</span></div><div><span style="font-size: 12pt;">这一块和自动拆装箱纠缠较多，关于自动拆装箱，参考</span> <a href="https://www.cnblogs.com/wang-yaz/p/8516151.html" style="font-size: 12pt;">https://www.cnblogs.com/wang-yaz/p/8516151.html</a></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">    public static Integer valueOf(int i) {</font></div><div><font style="font-size: 12pt;">        if (i &gt;= IntegerCache.low &amp;&amp; i &lt;=  IntegerCache.high)</font></div><div><font style="font-size: 12pt;">            return IntegerCache.cache[i +  (-IntegerCache.low)];</font></div><div><font style="font-size: 12pt;">        return new Integer(i);</font></div><div><font style="font-size: 12pt;">    }</font></div></div><div><span style="font-size: 12pt;">这个就是自动装箱时调用的函数，可以看到，在缓存范围内的，从缓存中直接取出对象，否则才新建一个Integer对象。</span></div><div><span style="font-size: 12pt;">下面写个简单的例子测试一下：</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">public class IntegerTest {</font></div><div><font style="font-size: 12pt;">     public static void main(String[] args) {</font></div><div><font style="font-size: 12pt;">          Integer i=Integer.valueOf(1);</font></div><div><font style="font-size: 12pt;">          Integer i1=1;</font></div><div><font style="font-size: 12pt;">          System.out.println(i==i1);</font></div><div><font style="font-size: 12pt;">          </font></div><div><font style="font-size: 12pt;">          Integer k=new Integer(1);</font></div><div><font style="font-size: 12pt;">          System.out.println(k==i);</font></div><div><font style="font-size: 12pt;">          </font></div><div><font style="font-size: 12pt;">          Integer j=Integer.valueOf(127);</font></div><div><font style="font-size: 12pt;">          Integer j1=Integer.valueOf(127);</font></div><div><font style="font-size: 12pt;">          System.out.println(j==j1);</font></div><div><font style="font-size: 12pt;">     }</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><span style="font-size: 12pt;">输出结果</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">true</font></div><div><font style="font-size: 12pt;">false</font></div><div><font style="font-size: 12pt;">true</font></div></div><div><span style="font-size: 12pt;">注意看第二个测试结果，别自己脑子抽了自己new一个对象，然后去比较，那能是同一个对象才有鬼了。</span></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 12pt;">Integer有缓存，那同为Number子孙的其他类是不是也有，于是</span></div><div><span style="font-size: 12pt;">Long</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class LongCache {</div><div>    private LongCache(){}</div><div>    static final Long cache[] = new Long[-(-128) + 127 + 1];</div><div>    static {</div><div>        for(int i = 0; i &lt; cache.length; i++)</div><div>            cache[i] = new Long(i - 128);</div><div>    }</div><div>}</div></div><div>Short</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class ShortCache {</div><div>    private ShortCache(){}</div><div><br/></div><div><br/></div><div>    static final Short cache[] = new Short[-(-128) + 127 + 1];</div><div><br/></div><div><br/></div><div>    static {</div><div>        for(int i = 0; i &lt; cache.length; i++)</div><div>            cache[i] = new Short((short)(i - 128));</div><div>    }</div><div>}</div></div><div>Byte</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class ByteCache {</div><div>    private ByteCache(){}</div><div><br/></div><div><br/></div><div>    static final Byte cache[] = new Byte[-(-128) + 127 + 1];</div><div><br/></div><div><br/></div><div>    static {</div><div>        for(int i = 0; i &lt; cache.length; i++)</div><div>            cache[i] = new Byte((byte)(i - 128));</div><div>    }</div><div>}</div></div><div>Double和Float是没有的，不过他们俩确实没有缓存的必要性。</div><div>八大包装基类，四个有两个无，剩余两个是不是也有？</div><div>Boolean这货必须有！但是去找了一下却没找到，有点吃惊。别的类都可以没有缓存，唯独它不可没有啊，我都能想到的问题，写jdk的大神会想不到？仔细找了下，果然，有两个不可变对象，相当于枚举。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public static Boolean valueOf(boolean b) {</div><div>    return (b ? TRUE : FALSE);</div><div>}</div><div>public static final Boolean TRUE = new Boolean(true);</div><div>public static final Boolean FALSE = new Boolean(false);</div></div><div>Character</div><div>它也缓存了前128个字符的包装类对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private static class CharacterCache {</div><div>    private CharacterCache(){}</div><div>    static final Character cache[] = new Character[127 + 1];</div><div>    static {</div><div>        for (int i = 0; i &lt; cache.length; i++)</div><div>            cache[i] = new Character((char)i);</div><div>    }</div><div>}</div></div><div><br/></div><div><span style="font-size: 14pt;">2、不可变性</span></div><div><br/></div><div><span style="font-size: 12pt;">Integer对象是个不可变对象，且继承自Number类。其他几个基础类型的装箱类也是如此。</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">public final class Integer extends Number implements  Comparable&lt;Integer&gt;{</font></div><div><font style="font-size: 12pt;">        private final int value;//值也是用final修饰的</font></div><div><font style="font-size: 12pt;">}</font></div></div><div><br/></div><div><span style="font-size: 14pt;">3、值比较</span></div><div><font style="font-size: 12pt;"><br/></font></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><font style="font-size: 12pt;">    public boolean equals(Object obj) {</font></div><div><font style="font-size: 12pt;">        if (obj instanceof Integer) {</font></div><div><font style="font-size: 12pt;">            return value == ((Integer)obj).intValue();</font></div><div><font style="font-size: 12pt;">        }</font></div><div><font style="font-size: 12pt;">        return false;</font></div><div><font style="font-size: 12pt;">    }</font></div><div><font style="font-size: 12pt;">    public int intValue() {</font></div><div><font style="font-size: 12pt;">        return value;</font></div><div><font style="font-size: 12pt;">    }</font></div></div><div><span style="font-size: 12pt;">可以看出，equals方法比较的是value属性值，换句话说是大小。</span></div><div><br/></div></span>
</div></body></html> 