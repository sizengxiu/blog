<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="497"/>

<div>
<span><div>主要学习构造函数、取值、存值和遍历这几个方面</div><div>1、先看介绍</div><div><img src="HashMap_files/HashMap.png" type="image/png" data-filename="HashMap.png"/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><br/></div><div>/**</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//大体意思：实现了Map接口，且key和value都允许null,除了这一点和没有现成同步，其他基本和</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">HashTable一样；而且，它不保证元素的顺序。</span></div><div>* Hash table based implementation of the &lt;tt&gt;Map&lt;/tt&gt;  interface.  This</div><div>* implementation provides all of the optional map  operations, and permits</div><div>* &lt;tt&gt;null&lt;/tt&gt; values and the &lt;tt&gt;null&lt;/tt&gt; key.  (The  &lt;tt&gt;HashMap&lt;/tt&gt;</div><div>* class is roughly equivalent to &lt;tt&gt;Hashtable&lt;/tt&gt;,  except that it is</div><div>* unsynchronized and permits nulls.)  This class makes  no guarantees as to</div><div>* the order of the map; in particular, it does not  guarantee that the order</div><div>* will remain constant over time.</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;"><br/></span></div><div>*HashMap提供常量时间内的存取操作，迭代器的效率和容量大小成正比，所以如果使用迭代器不要设置</div><div>过大的容量和负载因子（无效位置过多，迭代时浪费时间）</div><div>* &lt;p&gt;This implementation provides constant-time  performance for the basic</div><div>* operations (&lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;), assuming  the hash function</div><div>* disperses the elements properly among the buckets.   Iteration over</div><div>* collection views requires time proportional to the  &quot;capacity&quot; of the</div><div>* &lt;tt&gt;HashMap&lt;/tt&gt; instance (the number of buckets) plus  its size (the number</div><div>* of key-value mappings).  Thus, it's very important not  to set the initial</div><div>* capacity too high (or the load factor too low) if  iteration performance is</div><div>* important.</div><div>*数据数量到达负载因子时*容量时，容量会扩大为原来的两倍，数据会重新映射（<font color="#8600A4">这儿有点小坑，并不是完全重新映射</font></div><div><font color="#8600A4">这个部分有优化，后续会看到）</font></div><div>* &lt;p&gt;An instance of &lt;tt&gt;HashMap&lt;/tt&gt; has two parameters  that affect its</div><div>* performance: &lt;i&gt;initial capacity&lt;/i&gt; and &lt;i&gt;load  factor&lt;/i&gt;.  The</div><div>* &lt;i&gt;capacity&lt;/i&gt; is the number of buckets in the hash  table, and the initial</div><div>* capacity is simply the capacity at the time the hash  table is created.  The</div><div>* &lt;i&gt;load factor&lt;/i&gt; is a measure of how full the hash  table is allowed to</div><div>* get before its capacity is automatically increased.   When the number of</div><div>* entries in the hash table exceeds the product of the  load factor and the</div><div>* current capacity, the hash table is &lt;i&gt;rehashed&lt;/i&gt;  (that is, internal data</div><div>* structures are rebuilt) so that the hash table has  approximately twice the</div><div>* number of buckets.</div><div>*负载因子设为0.75是综合考虑时间和空间耗费的值，高了会提高空间利用率，低了会提高存取时间。</div><div>* &lt;p&gt;As a general rule, the default load factor (.75)  offers a good</div><div>* tradeoff between time and space costs.  Higher values  decrease the</div><div>* space overhead but increase the lookup cost (reflected  in most of</div><div>* the operations of the &lt;tt&gt;HashMap&lt;/tt&gt; class,  including</div><div>* &lt;tt&gt;get&lt;/tt&gt; and &lt;tt&gt;put&lt;/tt&gt;).  The expected number  of entries in</div><div>* the map and its load factor should be taken into  account when</div><div>* setting its initial capacity, so as to minimize the  number of</div><div>* rehash operations.  If the initial capacity is greater  than the</div><div>* maximum number of entries divided by the load factor,  no rehash</div><div>* operations will ever occur.</div><div>*</div><div>* &lt;p&gt;If many mappings are to be stored in a  &lt;tt&gt;HashMap&lt;/tt&gt;</div><div>* instance, creating it with a sufficiently large  capacity will allow</div><div>* the mappings to be stored more efficiently than  letting it perform</div><div>* automatic rehashing as needed to grow the table.  Note  that using</div><div>* many keys with the same {@code hashCode()} is a sure  way to slow</div><div>* down performance of any hash table. To ameliorate  impact, when keys</div><div>* are {@link Comparable}, this class may use comparison  order among</div><div>* keys to help break ties.</div><div>*</div><div>//非线性安全</div><div>* &lt;p&gt;&lt;strong&gt;Note that this implementation is not  synchronized.&lt;/strong&gt;</div><div>* If multiple threads access a hash map concurrently,  and at least one of</div><div>* the threads modifies the map structurally, it  &lt;i&gt;must&lt;/i&gt; be</div><div>* synchronized externally.  (A structural modification  is any operation</div><div>* that adds or deletes one or more mappings; merely  changing the value</div><div>* associated with a key that an instance already  contains is not a</div><div>* structural modification.)  This is typically  accomplished by</div><div>* synchronizing on some object that naturally  encapsulates the map.</div><div>*</div><div>* If no such object exists, the map should be &quot;wrapped&quot;  using the</div><div>* {@link Collections#synchronizedMap  Collections.synchronizedMap}</div><div>* method.  This is best done at creation time, to  prevent accidental</div><div>* unsynchronized access to the map:&lt;pre&gt;</div><div>*   Map m = Collections.synchronizedMap(new  HashMap(...));&lt;/pre&gt;</div><div>*</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//使用迭代器期间不允许修改map,除了迭代器自身的remove方法</span></div><div>* &lt;p&gt;The iterators returned by all of this class's  &quot;collection view methods&quot;</div><div>* are &lt;i&gt;fail-fast&lt;/i&gt;: if the map is structurally  modified at any time after</div><div>* the iterator is created, in any way except through the  iterator's own</div><div>* &lt;tt&gt;remove&lt;/tt&gt; method, the iterator will throw a</div><div>* {@link ConcurrentModificationException}.  Thus, in the  face of concurrent</div><div>* modification, the iterator fails quickly and cleanly,  rather than risking</div><div>* arbitrary, non-deterministic behavior at an  undetermined time in the</div><div>* future.</div><div>*</div><div>* &lt;p&gt;Note that the fail-fast behavior of an iterator  cannot be guaranteed</div><div>* as it is, generally speaking, impossible to make any  hard guarantees in the</div><div>* presence of unsynchronized concurrent modification.   Fail-fast iterators</div><div>* throw &lt;tt&gt;ConcurrentModificationException&lt;/tt&gt; on a  best-effort basis.</div><div>* Therefore, it would be wrong to write a program that  depended on this</div><div>* exception for its correctness: &lt;i&gt;the fail-fast  behavior of iterators</div><div>* should be used only to detect bugs.&lt;/i&gt;</div><div>*/</div><div>public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt;</div><div>    implements Map&lt;K,V&gt;, Cloneable, Serializable {</div><div>    /**</div><div>     * The default initial capacity - MUST be a power of  two.默认容量大小</div><div>     */</div><div>    static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; //  aka 16</div><div>    //默认负载因子</div><div>    static final float DEFAULT_LOAD_FACTOR = 0.75f;</div><div>    /**</div><div>     * The bin count threshold for using a tree rather  than list for a</div><div>     * bin.  Bins are converted to trees when adding an  element to a</div><div>     * bin with at least this many nodes. The value must  be greater</div><div>     * than 2 and should be at least 8 to mesh with  assumptions in</div><div>     * tree removal about conversion back to plain bins  upon</div><div>     * shrinkage.</div><div>     */</div><div>    static final int TREEIFY_THRESHOLD = 8;</div><div>    /**</div><div>     * The bin count threshold for untreeifying a (split)  bin during a</div><div>     * resize operation. Should be less than  TREEIFY_THRESHOLD, and at</div><div>     * most 6 to mesh with shrinkage detection under  removal.</div><div>     */</div><div>    static final int UNTREEIFY_THRESHOLD = 6;</div></div><div><br/></div><div>2、构造函数</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</div><div>* capacity and load factor.</div><div>*/</div><div>public HashMap(int initialCapacity, float loadFactor) {</div><div>    if (initialCapacity &lt; 0)</div><div>        throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +</div><div>                                           initialCapacity);</div><div>    if (initialCapacity &gt; MAXIMUM_CAPACITY)</div><div>        initialCapacity = MAXIMUM_CAPACITY;</div><div>    if (loadFactor &lt;= 0 || Float.isNaN(loadFactor))</div><div>        throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +</div><div>                                           loadFactor);</div><div>    this.loadFactor = loadFactor;</div><div>    this.threshold = tableSizeFor(initialCapacity);</div><div>}</div><div><br/></div><div><br/></div><div>/**</div><div>* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the specified initial</div><div>* capacity and the default load factor (0.75).</div><div>*/</div><div>public HashMap(int initialCapacity) {</div><div>    this(initialCapacity, DEFAULT_LOAD_FACTOR);</div><div>}</div><div><br/></div><div><br/></div><div>/**</div><div>* Constructs an empty &lt;tt&gt;HashMap&lt;/tt&gt; with the default initial capacity</div><div>* (16) and the default load factor (0.75).</div><div>*/</div><div>public HashMap() {</div><div>    this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted</div><div>}</div><div><br/></div><div><br/></div><div>/**</div><div>* Constructs a new &lt;tt&gt;HashMap&lt;/tt&gt; with the same mappings as the</div><div>* specified &lt;tt&gt;Map&lt;/tt&gt;.  The &lt;tt&gt;HashMap&lt;/tt&gt; is created with</div><div>* default load factor (0.75) and an initial capacity sufficient to</div><div>* hold the mappings in the specified &lt;tt&gt;Map&lt;/tt&gt;.</div><div>*/</div><div>public HashMap(Map&lt;? extends K, ? extends V&gt; m) {</div><div>    this.loadFactor = DEFAULT_LOAD_FACTOR;</div><div>    putMapEntries(m, false);</div><div>}</div></div><div>我们用的比较多的应该是第二个和第三个，指定初始容量大小的构造函数和无参构造函数。强烈建议优先使用第二个。先看下第二个</div><div>获取最近接2的次方的初始化大小</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final int tableSizeFor(int cap) {</div><div>    int n = cap - 1;</div><div>    n |= n &gt;&gt;&gt; 1;//这个会使得原本位置上为1（只关注最高位的1）的位其后的位上也变成1,此时最高位1和次高位都是1</div><div>    n |= n &gt;&gt;&gt; 2;//再右移两位相或，会使得最高位1后的三四位也变成1，后同理</div><div>    n |= n &gt;&gt;&gt; 4;</div><div>    n |= n &gt;&gt;&gt; 8;</div><div>    n |= n &gt;&gt;&gt; 16;</div><div>    return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;</div><div>}</div></div><div>至于为什么开始时要先减去1，最后再加上1.，以9为例，如果不这么做，获取的值是8，小于9，是不可取的，当然可以直接在最后左移一位来解决，比如等于7的时候，算出来的值是8，但是当初始化的值恰好是2的次方的时候会造成浪费，比方说8，计算出的值是16 ，凭空浪费了一半的空间。</div><div>注意初始化大小的值是赋给threshold的</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* The next size value at which to resize (capacity * load factor).</div><div>*</div><div>* @serial</div><div>*/</div><div>// (The javadoc description is true upon serialization.</div><div>// Additionally, if the table array has not been allocated, this</div><div>// field holds the initial array capacity, or zero signifying</div><div>// DEFAULT_INITIAL_CAPACITY.)</div><div>int threshold;</div></div><div>注释上写的是 这个值是记录下次扩容时的阈值的(capacity * load factor)</div><div><br/></div><div>众所周知，HashMap底层使用数组存储数据，可是上面构造函数中并未看到数组初始化相关的内容，这是为什么？数组的初始化，是在第一次往HashMap中放数据时才初始化，也就是懒加载。好处是使用时才申请空间，不适用不占用空间。</div><div><br/></div><div><br/></div><div>3、数据存储相关</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* <font color="#BC0058">The table, initialized on first use</font>, and resized as</div><div>* necessary. When allocated, length is always a power of two.</div><div>* (We also tolerate length zero in some operations to allow</div><div>* bootstrapping mechanics that are currently not needed.)</div><div>*/</div><div>transient Node&lt;K,V&gt;[] table;</div></div><div>HashMap使用node数组来存储数据，注释上来就声明了hashMap的Node数组，第一次使用时才进行初始化</div><div><br/></div><div>看一下Node结构</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Basic hash bin node, used for most entries.  (See below for</div><div>* TreeNode subclass, and in LinkedHashMap for its Entry subclass.)</div><div>*/</div><div>//Map.Entry是个接口  Map.Entry是个接口 Map.Entry是个接口</div><div>static class Node&lt;K,V&gt; implements <font style="color: rgb(188, 0, 88);">Map.Entry</font>&lt;K,V&gt; {</div><div>    final int hash;</div><div>    final K key;</div><div>    V value;</div><div>    Node&lt;K,V&gt; next;</div><div>    Node(int hash, K key, V value, Node&lt;K,V&gt; next) {</div><div>        this.hash = hash;</div><div>        this.key = key;</div><div>        this.value = value;</div><div>        this.next = next;</div><div>    }</div><div><br/></div><div>    public final K getKey()        { return key; }</div><div>    public final V getValue()      { return value; }</div><div>    public final String toString() { return key + &quot;=&quot; + value; }</div><div>    public final int hashCode() {</div><div>        return Objects.hashCode(key) ^ Objects.hashCode(value);</div><div>    }</div><div><br/></div><div>    public final V setValue(V newValue) {</div><div>        V oldValue = value;</div><div>        value = newValue;</div><div>        return oldValue;</div><div>    }</div><div><br/></div><div>    public final boolean equals(Object o) {</div><div>        if (o == this)</div><div>            return true;</div><div>        if (o instanceof Map.Entry) {</div><div>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</div><div>            if (Objects.equals(key, e.getKey()) &amp;&amp;</div><div>                Objects.equals(value, e.getValue()))</div><div>                return true;</div><div>        }</div><div>        return false;</div><div>    }</div><div>}</div></div><div>首先，Node实现了Map的内部接口Entry接口。</div><div>四个成员变量，除了我们知道的key/value外，还存储了hash值，这个值是用来通过hash函数计算存储位置的，最后一个是Node型的next，看到这个玩意儿的第一反应就是链表，事实确实如此，当不同的数据通过hash码映射到同一位置时，就会以链表的形式挂在该位置已有的数据上。</div><div>再看注释，这只是个基本的结构，当某个桶内的数据过多，转化成红黑树后，存储的结点就是树节点。</div><div>瞅一眼树节点</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; {</div><div>    TreeNode&lt;K,V&gt; parent;  // red-black tree links</div><div>    TreeNode&lt;K,V&gt; left;</div><div>    TreeNode&lt;K,V&gt; right;</div><div>    TreeNode&lt;K,V&gt; prev;    // needed to unlink next upon deletion</div><div>    boolean red;</div></div><div>它集成自LinkedHashMap.Entry，而这个Entry又集成自Node结点，所以TreeNode就是特殊的Node。记住这一点，后面有用到</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; {</div><div>    Entry&lt;K,V&gt; before, after;</div><div>    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) {</div><div>        super(hash, key, value, next);</div><div>    }</div><div>}</div></div><div><br/></div><div>4、获取数据</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V get(Object key) {</div><div>    Node&lt;K,V&gt; e;</div><div>    return (e = getNode(hash(key), key)) == null ? null : e.value;</div><div>}</div></div><div>先计算key的hash值</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Computes key.hashCode() and spreads (XORs) higher bits of hash</div><div>* to lower.  Because the table uses power-of-two masking, sets of</div><div>* hashes that vary only in bits above the current mask will</div><div>* always collide. (Among known examples are sets of Float keys</div><div>* holding consecutive whole numbers in small tables.)  So we</div><div>* apply a transform that spreads the impact of higher bits</div><div>* downward. There is a tradeoff between speed, utility, and</div><div>* quality of bit-spreading. Because many common sets of hashes</div><div>* are already reasonably distributed (so don't benefit from</div><div>* spreading), and because we use trees to handle large sets of</div><div>* collisions in bins, we just XOR some shifted bits in the</div><div>* cheapest possible way to reduce systematic lossage, as well as</div><div>* to incorporate impact of the highest bits that would otherwise</div><div>* never be used in index calculations because of table bounds.</div><div>*/</div><div>static final int hash(Object key) {</div><div>    int h;</div><div>    return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);</div><div>}</div></div><div>这个就是著名的扰动函数。HashMap进行hash映射时也就是根据hash码确定存储位置时，用的方法是(capacity-1)&amp;hash,就是数组的有效长度位和hash值进行相与，这种方式计算速度快，但是有个缺点，容易发生碰撞，</div><div>假设capacity=16,</div><div>capacity-1=0000000000000000000000000001111,</div><div>hash值是随机的整数值，和上面的值相与，会发现，实际有用的只是最后几位，前面的位上的数字并未产生作用。上面的扰动函数将hash码的前16位和后16位进行相与，高16位的值会使得低16的值发生变化，变相的使得高16位值也发生了作用，从而减少了碰撞的几率。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt; getNode(int hash, Object key) {</div><div>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;</div><div>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div>        (first = <font color="#EB0073">tab[(n - 1) &amp; hash]</font>) != null) {</div><div>        //通中第一个节点的hash值和key的hash值相等，直接返回</div><div>        if (first.hash == hash &amp;&amp; // always check first node</div><div>            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div>            return first;</div><div>        if ((e = first.next) != null) {</div><div>            //红黑树取节点</div><div>            if (first instanceof TreeNode)</div><div>                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</div><div>            //链表节点</div><div>            do {</div><div>                if (e.hash == hash &amp;&amp;</div><div>                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div>                    return e;</div><div>            } while ((e = e.next) != null);</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div><br/></div><div><br/></div><div>5、添加数据</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V put(K key, V value) {</div><div>    return putVal(hash(key), key, value, false, true);</div><div>}</div><div><br/></div><div>final V putVal(int hash, K key, V value, boolean onlyIfAbsent,</div><div>               boolean evict) {</div><div>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;</div><div>    //第一次存数据时，进行初始化操作</div><div>    if ((tab = table) == null || (n = tab.length) == 0)</div><div>        n = (tab = resize()).length;</div><div>    //如果该位置没有值，新建一个Node放到该位置</div><div>    if ((p = tab[i = (n - 1) &amp; hash]) == null)</div><div>        tab[i] = newNode(hash, key, value, null);</div><div>    else {</div><div>        Node&lt;K,V&gt; e; K k;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //p为桶的头结点</span></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                //如果桶的头结点的key和要存入的key相等，则直接覆盖</span></div><div>        if (p.hash == hash &amp;&amp;</div><div>            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div>            e = p;</div><div>        //如果桶中存储的是树，则在该树上处理</div><div>        else if (p instanceof TreeNode)</div><div>            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);</div><div>        else {</div><div>            //遍历该桶位置的链表</div><div>            for (int binCount = 0; ; ++binCount) {</div><div>                //链表中不存在相同的key则新增一个结点，挂在链表的最后</div><div>                if ((e = p.next) == null) {</div><div>                    p.next = newNode(hash, key, value, null);</div><div>                    //桶中结点数量大于树化阈值，则将链表转换为树</div><div>                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st</div><div>                        treeifyBin(tab, hash);</div><div>                    break;</div><div>                }</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">                            //遇到相等的key则覆盖</span></div><div>                if (e.hash == hash &amp;&amp;</div><div>                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div>                    break;</div><div>                p = e;</div><div>            }</div><div>        }</div><div>        //e是遍历中找到的已存在的老数据，不存在老数据（新增）则e为null</div><div>        if (e != null) { // existing mapping for key</div><div>            V oldValue = e.value;</div><div>            if (!onlyIfAbsent || oldValue == null)</div><div>                e.value = value;</div><div>            afterNodeAccess(e);</div><div>            return oldValue;//如果是新数据替换老数据，而不是新增，不会引发下面的modCount值的变化</div><div>        }</div><div>    }</div><div>    ++modCount;</div><div>    //如果达到扩容阈值，则进行扩容</div><div>    if (++size &gt; threshold)</div><div>        resize();</div><div>    afterNodeInsertion(evict);</div><div>    return null;</div><div>}</div><div><br/></div><div>// Callbacks to allow LinkedHashMap post-actions预留给子类LinkedHashMap实现的</div><div>void afterNodeAccess(Node&lt;K,V&gt; p) { }</div></div><div><br/></div><div>6、remove</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public V remove(Object key) {</div><div>    Node&lt;K,V&gt; e;</div><div>    return (e = removeNode(hash(key), key, null, false, true)) == null ?</div><div>        null : e.value;</div><div>}</div></div><div>看看实际干活的方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value,</div><div>                           boolean matchValue, boolean movable) {</div><div>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index;</div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">        //判断key存在</span></div><div>    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;</div><div>        (p = tab[index = (n - 1) &amp; hash]) != null) {</div><div>        Node&lt;K,V&gt; node = null, e; K k; V v;</div><div>        //key值地址相等和值相等满足一个提交即可</div><div>        if (p.hash == hash &amp;&amp;</div><div>            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))</div><div>            node = p;</div><div>        else if ((e = p.next) != null) {</div><div>            //树种查找</div><div>            if (p instanceof TreeNode)</div><div>                node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key);</div><div>            else {</div><div>                //链表查找</div><div>                do {</div><div>                    if (e.hash == hash &amp;&amp;</div><div>                        ((k = e.key) == key ||</div><div>                         (key != null &amp;&amp; key.equals(k)))) {</div><div>                        node = e;</div><div>                        break;</div><div>                    }</div><div>                    p = e;</div><div>                } while ((e = e.next) != null);</div><div>            }</div><div>        }</div><div>        if (node != null &amp;&amp; (!matchValue || (v = node.value) == value ||</div><div>                             (value != null &amp;&amp; value.equals(v)))) {</div><div>            //树中删除结点</div><div>            if (node instanceof TreeNode)</div><div>                ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable);</div><div>            //如果是桶中链表头结点，则将次结点变为头结点</div><div>            else if (node == p)</div><div>                tab[index] = node.next;</div><div>            else</div><div>                //普通的链表删除结点</div><div>                p.next = node.next;</div><div>            ++modCount;//迭代器防修改</div><div>            --size;</div><div>            // Callbacks to allow LinkedHashMap post-actions</div><div>            afterNodeRemoval(node);</div><div>            return node;</div><div>        }</div><div>    }</div><div>    return null;</div><div>}</div></div><div>上面树中怎么查找结点和删除结点，先跳过。</div><div><br/></div><div>7、resize()</div><div>初始化和扩容时调用</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final Node&lt;K,V&gt;[] resize() {</div><div>    Node&lt;K,V&gt;[] oldTab = table;</div><div>    int oldCap = (oldTab == null) ? 0 : oldTab.length;</div><div>    int oldThr = threshold;</div><div>    int newCap, newThr = 0;</div><div>    if (oldCap &gt; 0) {</div><div>        if (oldCap &gt;= MAXIMUM_CAPACITY) {</div><div>            threshold = Integer.MAX_VALUE;</div><div>            return oldTab;</div><div>        }//扩容，每次扩容为原来的两倍</div><div>        else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;</div><div>                 oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</div><div>            newThr = oldThr &lt;&lt; 1; // double threshold</div><div>    }</div><div>    //初始化，新建HashMap对象时调用了带初始化大小的构造函数</div><div>    else if (oldThr &gt; 0) // initial capacity was placed in threshold</div><div>        newCap = oldThr;</div><div>    //初始化，新建HashMap对象时调用无参构造函数</div><div>    else {               // zero initial threshold signifies using defaults</div><div>        newCap = DEFAULT_INITIAL_CAPACITY;</div><div>        newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</div><div>    }</div><div>    if (newThr == 0) {</div><div>        float ft = (float)newCap * loadFactor;</div><div>        newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?</div><div>                  (int)ft : Integer.MAX_VALUE);</div><div>    }</div><div>    threshold = newThr;</div><div>    @SuppressWarnings({&quot;rawtypes&quot;,&quot;unchecked&quot;})</div><div>        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap];//申请空间，初始化node数组</div><div>    table = newTab;</div><div>    if (oldTab != null) {</div><div>        for (int j = 0; j &lt; oldCap; ++j) {</div><div>            Node&lt;K,V&gt; e;</div><div>            //桶中有数据</div><div>            if ((e = oldTab[j]) != null) {</div><div>                oldTab[j] = null;</div><div>                //如果桶中只有一个结点，则直接重新hash映射</div><div>                if (e.next == null)</div><div>                    newTab[e.hash &amp; (newCap - 1)] = e;</div><div>                else if (e instanceof TreeNode)</div><div>                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);</div><div>                else { // preserve order</div><div>                    //下面这段贼有意思，大体思路是，loHead是指向低位链表的指针，所谓低位就是重新映射后桶的位置还在原来位置的位置，比方说桶大小为16，一个Node 的hash值为33，（以取余映射为例）它会被映射到桶号为1的桶中；扩容为32后，重新映射，它仍被映射到桶号为1的桶中，位置没有发生变化，这种结点且称为低位结点，相反的，位置发生变化的就是高位结点，用hiHead链表存储。最后，低位的结点放在原来位置的桶中，高位结点重新放映射，放到新的桶中，注意，由于只是数组长度增长了一倍，所以高位链表中的所有结点仍然会被映射到同一个桶中，所以和低位链表节点一样，只需要计算链表头结点的位置，把头结点放进去就可以了。这样最终不管桶中有多少个结点，最终最多只需要映射两次就可以将一个桶中的元素全部迁移到新数组中，大大节省了时间。此处再次体现了，hashMap使用的hash函数的好处。</div><div>                    //问题来了，为什么下面标红的if提交可以判断是高位还是低位？对比正常的找桶的过程e.hash &amp; (oldCap-1),oldCap和（oldCap-1）的区别，就是一个是只有最高位为1（2的n次方）,一个是所有都为1，如果hash值和oldCap相与值为0，则说明扩容两倍后，桶的位置仍会落在&lt;length/2的位置，也就是原来的桶中，且位置不会发生变化。仍以上面的33为例，可验证这个过程。</div><div>                    Node&lt;K,V&gt; loHead = null, loTail = null;</div><div>                    Node&lt;K,V&gt; hiHead = null, hiTail = null;</div><div>                    Node&lt;K,V&gt; next;</div><div>                    do {</div><div>                        next = e.next;</div><div>                        if (<font style="color: rgb(166, 0, 196);">(e.hash &amp; oldCap) == 0</font>) {</div><div>                            if (loTail == null)</div><div>                                loHead = e;</div><div>                            else</div><div>                                loTail.next = e;</div><div>                            loTail = e;</div><div>                        }</div><div>                        else {</div><div>                            if (hiTail == null)</div><div>                                hiHead = e;</div><div>                            else</div><div>                                hiTail.next = e;</div><div>                            hiTail = e;</div><div>                        }</div><div>                    } while ((e = next) != null);</div><div>                    if (loTail != null) {</div><div>                        loTail.next = null;</div><div>                        newTab[j] = loHead;</div><div>                    }</div><div>                    if (hiTail != null) {</div><div>                        hiTail.next = null;</div><div>                        newTab[j + oldCap] = hiHead;</div><div>                    }</div><div>                }</div><div>            }</div><div>        }</div><div>    }</div><div>    return newTab;</div><div>}</div></div><div>桶中数据为树的情况走下面的分支</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Splits nodes in a tree bin into lower and upper tree bins,</div><div>* or untreeifies if now too small. Called only from resize;</div><div>*/</div><div>final void split(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int index, int bit) {</div><div>    TreeNode&lt;K,V&gt; b = this;</div><div>    // Relink into lo and hi lists, preserving order</div><div>    TreeNode&lt;K,V&gt; loHead = null, loTail = null;</div><div>    TreeNode&lt;K,V&gt; hiHead = null, hiTail = null;</div><div>    int lc = 0, hc = 0;</div><div>    //先说这个for循环，主要目的和上面桶是链表时一样，将节点分别挂在高位链表和低位链表上。</div><div>    //上面已经提到过，TreeNode继承自LinkedHashMap.Entry，所以它还是个链表结构，有前后指针，所以此处代码和上面桶中结点是链表时基本一致。</div><div>    for (TreeNode&lt;K,V&gt; e = b, next; e != null; e = next) {</div><div>        next = (TreeNode&lt;K,V&gt;)e.next;</div><div>        e.next = null;</div><div>        if ((e.hash &amp; bit) == 0) {</div><div>            if ((e.prev = loTail) == null)</div><div>                loHead = e;</div><div>            else</div><div>                loTail.next = e;</div><div>            loTail = e;</div><div>            ++lc;</div><div>        }</div><div>        else {</div><div>            if ((e.prev = hiTail) == null)</div><div>                hiHead = e;</div><div>            else</div><div>                hiTail.next = e;</div><div>            hiTail = e;</div><div>            ++hc;</div><div>        }</div><div>    }</div><div><br/></div><div>    //下面两个if分别处理高位结点和低位结点</div><div>    if (loHead != null) {</div><div>        if (lc &lt;= UNTREEIFY_THRESHOLD)</div><div>            //链表节点数量小于树化阈值的时候，将树TreeNode转化为普通Node</div><div>            tab[index] = loHead.untreeify(map);</div><div>        else {</div><div>            tab[index] = loHead;</div><div>            if (hiHead != null) // (else is already treeified)</div><div>                //虽然去恶补了下红黑树的知识，但是点开代码的匆匆扫了一眼之后，我觉得的红黑树的知识要细细雕琢一下之后再去看吧</div><div>                loHead.treeify(tab);</div><div>        }</div><div>    }</div><div>    if (hiHead != null) {</div><div>        if (hc &lt;= UNTREEIFY_THRESHOLD)</div><div>            tab[index + bit] = hiHead.untreeify(map);</div><div>        else {</div><div>            tab[index + bit] = hiHead;</div><div>            if (loHead != null)</div><div>                hiHead.treeify(tab);</div><div>        }</div><div>    }</div><div>}</div><div><br/></div></div><div><br/></div><div>untreeify方法是TreeNode类提供的方法，</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Returns a list of non-TreeNodes replacing those linked from this node.</div><div>*/</div><div>final Node&lt;K,V&gt; untreeify(HashMap&lt;K,V&gt; map) {</div><div>    Node&lt;K,V&gt; hd = null, tl = null;</div><div>    //此处的this指向的是调用该方法的TreeNode结点，也就是上一步中高位或者地位链表的头结点</div><div>    for (Node&lt;K,V&gt; q = this; q != null; q = q.next) {</div><div>        //结点转化</div><div>        Node&lt;K,V&gt; p = map.replacementNode(q, null);</div><div>        if (tl == null)</div><div>            hd = p;</div><div>        else</div><div>            tl.next = p;</div><div>        tl = p;</div><div>    }</div><div>    return hd;</div><div>}</div><div><br/></div><div>Node&lt;K,V&gt; replacementNode(Node&lt;K,V&gt; p, Node&lt;K,V&gt; next) {</div><div>    return new Node&lt;&gt;(p.hash, p.key, p.value, next);</div><div>}</div></div><div><br/></div><div>8、遍历</div><div>我们常用的遍历方式不外乎以下几种：按key遍历、按value遍历、按entrySet遍历</div><div>a、按key遍历</div><div>地球人都知道HashMap实现了Map接口，Map接口中有个keySet()方法，看看看HashMap对此方法的实现</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Returns a {@link Set} view of the keys contained in this map.</div><div>* The set is backed by the map, so changes to the map are</div><div>* reflected in the set, and vice-versa.  If the map is modified</div><div>* while an iteration over the set is in progress (except through</div><div>* the iterator's own &lt;tt&gt;remove&lt;/tt&gt; operation), the results of</div><div>* the iteration are undefined.  The set supports element removal,</div><div>* which removes the corresponding mapping from the map, via the</div><div>* &lt;tt&gt;Iterator.remove&lt;/tt&gt;, &lt;tt&gt;Set.remove&lt;/tt&gt;,</div><div>* &lt;tt&gt;removeAll&lt;/tt&gt;, &lt;tt&gt;retainAll&lt;/tt&gt;, and &lt;tt&gt;clear&lt;/tt&gt;</div><div>* operations.  It does not support the &lt;tt&gt;add&lt;/tt&gt; or &lt;tt&gt;addAll&lt;/tt&gt;</div><div>* operations.</div><div>*</div><div>* @return a set view of the keys contained in this map</div><div>*/</div><div>public Set&lt;K&gt; keySet() {</div><div>    Set&lt;K&gt; ks = keySet;//这个keySet是父类AbstractMap提供的成员变量，是个普通的Map，但是上面put数据的时候并没有看到往这个set中存数据，所以猜测又是懒加载</div><div>    if (ks == null) {</div><div>        ks = new KeySet();</div><div>        keySet = ks;</div><div>    }</div><div>    return ks;</div><div>}</div></div><div>KeySet是HashMap的内部类</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class KeySet extends AbstractSet&lt;K&gt; {</div><div>    public final int size()                 { return size; }</div><div>    public final void clear()               { HashMap.this.clear(); }</div><div>    public final Iterator&lt;K&gt; iterator()     { return new KeyIterator(); }</div><div>    public final boolean contains(Object o) { return containsKey(o); }</div><div>    public final boolean remove(Object key) {</div><div>        return removeNode(hash(key), key, null, false, true) != null;</div><div>    }</div><div>    public final Spliterator&lt;K&gt; spliterator() {</div><div>        return new KeySpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</div><div>    }</div><div>    public final void forEach(Consumer&lt;? super K&gt; action) {</div><div>        Node&lt;K,V&gt;[] tab;</div><div>        if (action == null)</div><div>            throw new NullPointerException();</div><div>        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</div><div>            int mc = modCount;</div><div>            for (int i = 0; i &lt; tab.length; ++i) {</div><div>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</div><div>                    action.accept(e.key);</div><div>            }</div><div>            if (modCount != mc)</div><div>                throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div><div>}</div><div>public abstract class AbstractSet&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Set&lt;E&gt; {</div></div><div>KeySet并没有显示的提供构造函数，找父类的构造函数，空的，再父类，又空的。这什么情况？作为一名有经验的初级开发人员，这种问题难不倒我，去翻文档嘛，查了keySet方法说明，嗯，并没有说明怎么初始化的。 </div><div>仔细看下这个类的方法：size()、clear()、contains()都是调用的hashMap的对应的方法。下面着重看一下迭代器，迭代器方法返回的是KeyIterator</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class KeyIterator extends HashIterator</div><div>    implements Iterator&lt;K&gt; {</div><div>    public final K next() { return nextNode().key; }</div><div>}</div></div><div>而KeyIterator继承自HashIterator</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>abstract class HashIterator {</div><div>    Node&lt;K,V&gt; next;        // next entry to return</div><div>    Node&lt;K,V&gt; current;     // current entry</div><div>    int expectedModCount;  // for fast-fail</div><div>    int index;             // current slot</div><div><br/></div><div><br/></div><div>    HashIterator() {</div><div>        expectedModCount = modCount;</div><div>        Node&lt;K,V&gt;[] t = table;</div><div>        current = next = null;</div><div>        index = 0;</div><div>        if (t != null &amp;&amp; size &gt; 0) { // advance to first entry</div><div>            //下面的循环的目的是找到第一不为空的桶的头结点</div><div>            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    public final boolean hasNext() {</div><div>        return next != null;</div><div>    }</div><div><br/></div><div>    final Node&lt;K,V&gt; nextNode() {</div><div>        Node&lt;K,V&gt;[] t;</div><div>        Node&lt;K,V&gt; e = next;</div><div>        //有无修改检测</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>        if (e == null)</div><div>            throw new NoSuchElementException();</div><div>        //一个桶中的结点遍历完了之后，开始寻找下一个不为空的桶</div><div>        if ((next = (current = e).next) == null &amp;&amp; (t = table) != null) {</div><div>            do {} while (index &lt; t.length &amp;&amp; (next = t[index++]) == null);</div><div>        }</div><div>        return e;</div><div>    }</div><div><br/></div><div>    public final void remove() {</div><div>        Node&lt;K,V&gt; p = current;</div><div>        if (p == null)</div><div>            throw new IllegalStateException();</div><div>        if (modCount != expectedModCount)</div><div>            throw new ConcurrentModificationException();</div><div>        current = null;</div><div>        K key = p.key;</div><div>        //直接调用的hashMap的删除方法</div><div>        removeNode(hash(key), key, null, false, false);</div><div>        expectedModCount = modCount;</div><div>    }</div><div>}</div></div><div>其中主要的nextNode()和remove()都是直接操作HashMap,验证了KeySet中并没有存储数据，否则的话直接遍历它本身，将方便的多。</div><div>后来看到一篇博客说，keySet本身并不存数据<a href="https://blog.csdn.net/li_canhui/article/details/85051250">https://blog.csdn.net/li_canhui/article/details/85051250</a></div><div>注意，KeySet不能调用add方法，虽然它实现了set接口，如果调用它会抛出一个不支持的操作异常UnsupportedOperationException砸在你的脸上（其实是调用父类的方法）</div><div><br/></div><div>b、按照value遍历</div><div>values()方法和keySet()方法如出一辙，看完上面的按key遍历之后再看这个，一目了然</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Collection&lt;V&gt; values() {</div><div>    Collection&lt;V&gt; vs = values;</div><div>    if (vs == null) {</div><div>        vs = new Values();</div><div>        values = vs;</div><div>    }</div><div>    return vs;</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class Values extends AbstractCollection&lt;V&gt; {</div><div>    public final int size()                 { return size; }</div><div>    public final void clear()               { HashMap.this.clear(); }</div><div>    public final Iterator&lt;V&gt; iterator()     { return new ValueIterator(); }</div><div>    public final boolean contains(Object o) { return containsValue(o); }</div><div>    public final Spliterator&lt;V&gt; spliterator() {</div><div>        return new ValueSpliterator&lt;&gt;(HashMap.this, 0, -1, 0, 0);</div><div>    }</div><div>    public final void forEach(Consumer&lt;? super V&gt; action) {</div><div>        Node&lt;K,V&gt;[] tab;</div><div>        if (action == null)</div><div>            throw new NullPointerException();</div><div>        if (size &gt; 0 &amp;&amp; (tab = table) != null) {</div><div>            int mc = modCount;</div><div>            for (int i = 0; i &lt; tab.length; ++i) {</div><div>                for (Node&lt;K,V&gt; e = tab[i]; e != null; e = e.next)</div><div>                    action.accept(e.value);</div><div>            }</div><div>            if (modCount != mc)</div><div>                throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div><div>}</div></div><div>再看它的迭代器ValueIterator</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class ValueIterator extends HashIterator</div><div>    implements Iterator&lt;V&gt; {</div><div>    public final V next() { return nextNode().value; }</div><div>}</div></div><div>同样是继承自HashIterator，它的next方法返回的是node的value</div><div><br/></div><div>c、按EntrySet</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet() {</div><div>    Set&lt;Map.Entry&lt;K,V&gt;&gt; es;</div><div>    return (es = entrySet) == null ? (entrySet = new EntrySet()) : es;</div><div>}</div></div><div>看一下内部类EntrySet的主要方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class EntrySet extends AbstractSet&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    public final int size()                 { return size; }</div><div>    public final void clear()               { HashMap.this.clear(); }</div><div>    public final Iterator&lt;Map.Entry&lt;K,V&gt;&gt; iterator() {</div><div>        return new EntryIterator();</div><div>    }</div><div>    public final boolean contains(Object o) {</div><div>        if (!(o instanceof Map.Entry))</div><div>            return false;</div><div>        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div>        Object key = e.getKey();</div><div>        Node&lt;K,V&gt; candidate = getNode(hash(key), key);</div><div>        return candidate != null &amp;&amp; candidate.equals(e);</div><div>    }</div><div>    public final boolean remove(Object o) {</div><div>        if (o instanceof Map.Entry) {</div><div>            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;) o;</div><div>            Object key = e.getKey();</div><div>            Object value = e.getValue();</div><div>            return removeNode(hash(key), key, value, true, true) != null;</div><div>        }</div><div>        return false;</div><div>    }</div></div><div>size()、clear()、contains()和remove()本质上调用的还是HashMap方法。</div><div>迭代器返回的是EntryIterator对象</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final class EntryIterator extends HashIterator</div><div>    implements Iterator&lt;Map.Entry&lt;K,V&gt;&gt; {</div><div>    public final Map.Entry&lt;K,V&gt; next() { return nextNode(); }</div><div>}</div></div><div>又和上面的KeySet/Value的迭代器一样，此时的next()返回的是结点</div><div>看到此处才知道，网上一搜一大片的所谓的四种遍历方式是多不靠谱。</div><div>再来对比一下三者遍历的效率吧，都已经看过实现的源码了，再去对比这个，感觉索然无味。三者都是通过HashIterator实现的，都是挨个桶挨个结点访问。所以如果单纯的遍历key,keySet和entrySet效率一致，单纯遍历value,values和entrySet效率一致，如果遍历时同时需要key和value信息，entryMap最高，因为keySet拿到key还要再做一遍查找操作。</div><div>都提到这个了，那顺便再看一下toString方法</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public String toString() {</div><div>    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</div><div>    if (! i.hasNext())</div><div>        return &quot;{}&quot;;</div><div><br/></div><div><br/></div><div>    StringBuilder sb = new StringBuilder();</div><div>    sb.append('{');</div><div>    for (;;) {</div><div>        Entry&lt;K,V&gt; e = i.next();</div><div>        K key = e.getKey();</div><div>        V value = e.getValue();</div><div>        sb.append(key   == this ? &quot;(this Map)&quot; : key);</div><div>        sb.append('=');</div><div>        sb.append(value == this ? &quot;(this Map)&quot; : value);</div><div>        if (! i.hasNext())</div><div>            return sb.append('}').toString();</div><div>        sb.append(',').append(' ');</div><div>    }</div><div>}</div></div><div>果然用的entrySet进行遍历，HashMap没有重写toString方法，所以调用的时候实际上是调用的父类abstractMap的toString方法</div></span>
</div></body></html> 