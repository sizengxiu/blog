<html>
<head>
  <title>Evernote Export</title>
  <basefont face="微软雅黑" size="2" />
  <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
  <meta name="exporter-version" content="YXBJ Windows/601748 (zh-CN, DDL); Windows/6.1.1 (Win64); EDAMVersion=V2;"/>
  <style>
    body, td {
      font-family: 微软雅黑;
      font-size: 10pt;
    }
  </style>
</head>
<body>
<a name="494"/>

<div>
<span><div><br/></div><div>1、<span style="font-size: 12pt;">构造函数</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Constructs an empty list with an initial capacity of ten.</div><div>*/</div><div>public ArrayList() {</div><div>    this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</div><div>}</div><div><br/></div><div>private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = {};</div></div><div>    <span style="white-space: pre-wrap; text-indent: 56px; font-size: 16px; line-height: 1.75;">此时elementData指向的是一个长度为0的空数组，后面每次调用的时候都会扩容。</span><span style="white-space: pre-wrap; text-indent: 28px; font-size: 16px; color: rgb(63, 95, 191); line-height: 1.75;">所以，应尽量使用带初始化大小的构造函数</span></div><div><span style="white-space: pre-wrap; text-indent: 28px; font-size: 16px; color: rgb(63, 95, 191); line-height: 1.75;">2、添加数据</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Appends the specified element to the end of this list.</div><div>*</div><div>* @param e element to be appended to this list</div><div>* @return &lt;tt&gt;true&lt;/tt&gt; (as specified by {@link Collection#add})</div><div>*/</div><div>public boolean add(E e) {</div><div>    //是为了确认容量是否够用</div><div>    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div>    elementData[size++] = e;</div><div>    return true;</div><div>}</div></div><div><span style="font-size: 12pt;"><br/></span></div><div><span style="font-size: 11pt;">第一步确认容量大小，不够用则扩容；第二步将待加入的值放入数组后面，并将size+1,</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void ensureCapacityInternal(int minCapacity) {</div><div>    if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) {</div><div>        minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity);</div><div>    }</div><div>    ensureExplicitCapacity(minCapacity);</div><div>}</div></div><div>默认容量大小为10</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>/**</div><div>* Default initial capacity.</div><div>*/</div><div>private static final int DEFAULT_CAPACITY = 10;</div></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void ensureExplicitCapacity(int minCapacity) {</div><div>    modCount++;//检测有无修改时使用</div><div>    // overflow-conscious code</div><div>    if (minCapacity - elementData.length &gt; 0)</div><div>        grow(minCapacity);</div><div>}</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void grow(int minCapacity) {</div><div>    // overflow-conscious code</div><div>    int oldCapacity = elementData.length;</div><div>    int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);//每次扩容为原来的1.5倍</div><div>    if (newCapacity - minCapacity &lt; 0)</div><div>        newCapacity = minCapacity;</div><div>    if (newCapacity - MAX_ARRAY_SIZE &gt; 0)</div><div>        newCapacity = hugeCapacity(minCapacity);</div><div>    // minCapacity is usually close to size, so this is a win:</div><div>    elementData = Arrays.copyOf(elementData, newCapacity);</div><div>}</div></div><div>每次扩容为原来容量的1.5倍，如果还不够用，新的容量大小则用minCapacity，然后进行数据迁移Arrays.copyOf，内部调用System.arraycopy进行复制</div><div><br/></div><div><span style="font-size: 12pt;">3、在指定位置添加数据</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public void add(int index, E element) {</div><div>    rangeCheckForAdd(index);</div><div><br/></div><div>    ensureCapacityInternal(size + 1);  // Increments modCount!!</div><div>    System.arraycopy(elementData, index, elementData, index + 1,</div><div>                     size - index);</div><div>    elementData[index] = element;</div><div>    size++;</div><div>}</div></div><div><br/></div><div>和add函数相比，多了个位置有效性校验rangeCheckForAdd和数据复制。</div><div>有效性校验一目了然：</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void rangeCheckForAdd(int index) {</div><div>    if (index &gt; size || index &lt; 0)</div><div>        throw new IndexOutOfBoundsException(outOfBoundsMsg(index));</div><div>}</div></div><div>数据复制则是调用native方法System.arraycopy，将要插入位置的数据往后挪了一位。（竟然可以对同一个数组的重叠位置实现调用，找了几篇文章也没看懂为什么）</div><div>然后将新数据填入，数组长度+1。</div><div><br/></div><div><span style="font-size: 12pt;">4、删除数据</span></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean remove(Object o) {</div><div>    if (o == null) {</div><div>        for (int index = 0; index &lt; size; index++)</div><div>            if (elementData[index] == null) {</div><div>                fastRemove(index);</div><div>                return true;</div><div>            }</div><div>    } else {</div><div>        for (int index = 0; index &lt; size; index++)</div><div>            if (o.equals(elementData[index])) {</div><div>                fastRemove(index);</div><div>                return true;</div><div>            }</div><div>    }</div><div>    return false;</div><div>}</div></div><div>分了null和非null中情况，判断相等用的是equals方法；核心方法也是实际移除元素的的函数fastRemove</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private void fastRemove(int index) {</div><div>    modCount++;</div><div>    int numMoved = size - index - 1;</div><div>    if (numMoved &gt; 0)</div><div>        System.arraycopy(elementData, index+1, elementData, index,</div><div>                         numMoved);</div><div>    elementData[--size] = null; // clear to let GC do its work</div><div>}</div></div><div>又是调用了System.arraycopy进行挪移元素，最后将空出来的最后位置size-1的元素置空，注意此时，size虽然变了，但是存储数据的数组长度并没有变化</div><div>同时注意又见modCount++; 后续会一起说明它的作用</div><div><br/></div><div><span style="font-size: 12pt;">5、删除指定位置元素</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public E remove(int index) {</div><div>    rangeCheck(index);</div><div><br/></div><div><br/></div><div>    modCount++;</div><div>    E oldValue = elementData(index);</div><div><br/></div><div><br/></div><div>    int numMoved = size - index - 1;</div><div>    if (numMoved &gt; 0)</div><div>        System.arraycopy(elementData, index+1, elementData, index,</div><div>                         numMoved);</div><div>    elementData[--size] = null; // clear to let GC do its work</div><div><br/></div><div><br/></div><div>    return oldValue;</div><div>}</div></div><div>除了多了一个位置有效性检测外，后面内容就是把上面fastRemove函数粘了过来。</div><div><font style="font-size: 12pt;"><br/></font></div><div><span style="font-size: 12pt;">6、迭代器</span></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public Iterator&lt;E&gt; iterator() {</div><div>    return new Itr();</div><div>}</div></div><div><br/></div><div>   迭代器是ArrayList的一个内部类，实现了Iterator接口。  先看看迭代器的属性</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private class Itr implements Iterator&lt;E&gt; {</div><div>    int cursor;       // index of next element to return，当前位置</div><div>    int lastRet = -1; // index of last element returned; -1 if no such 上一个位置</div><div>    int expectedModCount = modCount;//期望的修改次数</div></div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public boolean hasNext() {</div><div>    return cursor != size;</div><div>}</div></div><div>hasNext方法就是判断当前位置指针有没结束</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>public E next() {</div><div>    checkForComodification();</div><div>    int i = cursor;</div><div>    if (i &gt;= size)</div><div>        throw new NoSuchElementException();</div><div>    Object[] elementData = ArrayList.this.elementData;</div><div>    if (i &gt;= elementData.length)</div><div>        throw new ConcurrentModificationException();</div><div>    cursor = i + 1;</div><div>    return (E) elementData[lastRet = i];</div><div>}</div></div><div>获取下一个元素，看到此处，其实就是数组直接定位位置，只是多了checkForComodification</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>final void checkForComodification() {</div><div>    if (modCount != expectedModCount)</div><div>        throw new ConcurrentModificationException();</div><div>}</div></div><div>终于看到了最常见的ConcurrentModificationException异常，每次获取迭代器，拿到的都是一个新生成的对象，此时expectedModCount==modCount，看看上面的add和remove方法，这两个方法内部都有一个modCount++,也就是修改次数+1，一旦有了调用就会使得modCount != expectedModCount，从而抛出异常。</div><div>注意，set方法中并没有修改modCount,所以调用set方法并不会抛出这个异常。</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">//迭代器的remove</span></div><div>public void remove() {</div><div>    if (lastRet &lt; 0)</div><div>        throw new IllegalStateException();</div><div>    checkForComodification();</div><div><br/></div><div><br/></div><div>    try {</div><div>        ArrayList.this.remove(lastRet);</div><div>        cursor = lastRet;</div><div>        lastRet = -1;</div><div>        expectedModCount = modCount;</div><div>    } catch (IndexOutOfBoundsException ex) {</div><div>        throw new ConcurrentModificationException();</div><div>    }</div><div>}</div></div><div>那为什么迭代器可以删除元素？因为迭代器每次删除数据，会同步修改expectedModCount的值，当然不会发生expectedModCount!=modCount的情况，自己的变量可以随意修改，任性。</div><div>foreach循环中为什么会抛出checkForComodification异常？因为foreach底层还是调用的迭代器进行循环。</div><div><br/></div><div>他还有一个迭代器ListIterator，继承自Itr。多了向前遍历的功能。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>private class ListItr extends Itr implements ListIterator&lt;E&gt; {</div><div>    ListItr(int index) {</div><div>        super();</div><div>        cursor = index;</div><div>    }</div><div><br/></div><div>    public boolean hasPrevious() {</div><div>        return cursor != 0;</div><div>    }</div><div>    public int nextIndex() {</div><div>        return cursor;</div><div>    }</div><div><br/></div><div>    public int previousIndex() {</div><div>        return cursor - 1;</div><div>    }</div><div><br/></div><div>    @SuppressWarnings(&quot;unchecked&quot;)</div><div>    public E previous() {</div><div>        checkForComodification();</div><div>        int i = cursor - 1;</div><div>        if (i &lt; 0)</div><div>            throw new NoSuchElementException();</div><div>        Object[] elementData = ArrayList.this.elementData;</div><div>        if (i &gt;= elementData.length)</div><div>            throw new ConcurrentModificationException();</div><div>        cursor = i;</div><div>        return (E) elementData[lastRet = i];</div><div>    }</div><div><br/></div><div>    public void set(E e) {</div><div>        if (lastRet &lt; 0)</div><div>            throw new IllegalStateException();</div><div>        checkForComodification();</div><div><br/></div><div>        try {</div><div>            ArrayList.this.set(lastRet, e);</div><div>        } catch (IndexOutOfBoundsException ex) {</div><div>            throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div><div><br/></div><div><br/></div><div>    public void add(E e) {</div><div>        checkForComodification();</div><div><br/></div><div><br/></div><div>        try {</div><div>            int i = cursor;</div><div>            ArrayList.this.add(i, e);</div><div>            cursor = i + 1;</div><div>            lastRet = -1;</div><div>            expectedModCount = modCount;</div><div>        } catch (IndexOutOfBoundsException ex) {</div><div>            throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div><div>}</div></div><div>注意这个迭代器的构造函数，可以接收一个位置参数，避免了每次遍历都要从头开始的尴尬。另外还提供了set方法，迭代期间不允许其他线程增删。</div><div><br/></div><div><br/></div><div>7、序列化</div><div><br/></div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>transient Object[] elementData;</div></div><div>这elementData就是ArrayList存储数据的地方，ArrayList实现了Serializable接口，但是这个存储实体却用了transient修饰，阻止他进行序列化。为什么要这么做？前面看到了，新增元素的时候会导致数组长度增加，但是第四小节删除的时候，已经看到，删除并不会缩短数组长度。这么做的目的很好理解，以空间换时间，已size属性标记数组的使用长度，从而避免了删除数组，重新申请一个新的数组，然后要把数据复制到新数组中。</div><div>那序列化怎么办？重写序列化过程。</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>    private void writeObject(java.io.ObjectOutputStream s)</div><div>        throws java.io.IOException{</div><div>        // Write out element count, and any hidden stuff</div><div>        int expectedModCount = modCount;</div><div>        s.defaultWriteObject();</div><div>        // Write out size as capacity for behavioural  compatibility with clone()</div><div>        s.writeInt(size);</div><div>        // Write out all elements in the proper order.</div><div>        for (int i=0; i&lt;size; i++) {</div><div>            s.writeObject(elementData[i]);</div><div>        }</div><div>        if (modCount != expectedModCount) {</div><div>            throw new ConcurrentModificationException();</div><div>        }</div><div>    }</div></div><div>反序列化</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>   private void readObject(java.io.ObjectInputStream s)</div><div>        throws java.io.IOException, ClassNotFoundException  {</div><div>        elementData = EMPTY_ELEMENTDATA;</div><div>        // Read in size, and any hidden stuff</div><div>        s.defaultReadObject();</div><div>        // Read in capacity</div><div>        s.readInt(); // ignored</div><div>        if (size &gt; 0) {</div><div>            // be like clone(), allocate array based upon  size not capacity</div><div>            ensureCapacityInternal(size);</div><div>            Object[] a = elementData;</div><div>            // Read in all elements in the proper order.</div><div>            for (int i=0; i&lt;size; i++) {</div><div>                a[i] = s.readObject();</div><div>            }</div><div>        }</div><div>    }</div></div><div><br/></div><div>贴一段Serializable接口上的注释</div><div style="box-sizing: border-box; padding: 8px; font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-size: 12px; color: rgb(51, 51, 51); border-radius: 4px; background-color: rgb(251, 250, 248); border: 1px solid rgba(0, 0, 0, 0.15);-en-codeblock:true;"><div>* Classes that require special handling during the serialization and</div><div>* deserialization process must implement special methods with these exact</div><div>* signatures:</div><div>*</div><div>* &lt;PRE&gt;</div><div>* private void writeObject(java.io.ObjectOutputStream out)</div><div>*     throws IOException</div><div>* private void readObject(java.io.ObjectInputStream in)</div><div>*     throws IOException, ClassNotFoundException;</div><div>* private void readObjectNoData()</div><div>*     throws ObjectStreamException;</div><div>* &lt;/PRE&gt;</div><div>*</div><div>* &lt;p&gt;The writeObject method is responsible for writing the state of the</div><div>* object for its particular class so that the corresponding</div><div>* readObject method can restore it.  The default mechanism for saving</div><div>* the Object's fields can be invoked by calling</div><div>* out.defaultWriteObject. The method does not need to concern</div><div>* itself with the state belonging to its superclasses or subclasses.</div><div>* State is saved by writing the individual fields to the</div><div>* ObjectOutputStream using the writeObject method or by using the</div><div>* methods for primitive data types supported by DataOutput.</div><div>*</div><div>* &lt;p&gt;The readObject method is responsible for reading from the stream and</div><div>* restoring the classes fields. It may call in.defaultReadObject to invoke</div><div>* the default mechanism for restoring the object's non-static and</div><div>* non-transient fields.  The defaultReadObject method uses information in</div><div>* the stream to assign the fields of the object saved in the stream with the</div><div>* correspondingly named fields in the current object.  This handles the case</div><div>* when the class has evolved to add new fields. The method does not need to</div><div>* concern itself with the state belonging to its superclasses or subclasses.</div><div>* State is saved by writing the individual fields to the</div><div>* ObjectOutputStream using the writeObject method or by using the</div><div>* methods for primitive data types supported by DataOutput.</div></div><div><span style="font-size: 9pt; color: rgb(51, 51, 51); font-family: Monaco;">第一句就指明了，如果序列化和反序列化的时候，需要特殊操作，重写</span> <span style="font-size: 12px; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-color: rgb(251, 250, 248); color: rgb(51, 51, 51); font-family: Monaco, Menlo, Consolas, &quot;Courier New&quot;, monospace; font-variant-caps: normal; font-variant-ligatures: normal;">writeObject和readObject函数</span></div></span>
</div></body></html> 